-- phpMyAdmin SQL Dump
-- version 4.2.7.1
-- http://www.phpmyadmin.net
--
-- Host: 127.0.0.1
-- Generation Time: Jul 23, 2015 at 10:07 PM
-- Server version: 5.6.20
-- PHP Version: 5.5.15

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- Database: `coding_tutorial`
--

-- --------------------------------------------------------

--
-- Table structure for table `algorithms`
--

CREATE TABLE IF NOT EXISTS `algorithms` (
`algo_id` int(6) NOT NULL,
  `author` varchar(30) NOT NULL,
  `date` date NOT NULL,
  `title` varchar(100) NOT NULL,
  `short_note` varchar(200) NOT NULL,
  `code` text NOT NULL,
  `description` text NOT NULL,
  `analysis` text NOT NULL,
  `category` varchar(30) NOT NULL,
  `tags` varchar(100) NOT NULL,
  `View` int(6) NOT NULL DEFAULT '10'
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=54 ;

--
-- Dumping data for table `algorithms`
--

INSERT INTO `algorithms` (`algo_id`, `author`, `date`, `title`, `short_note`, `code`, `description`, `analysis`, `category`, `tags`, `View`) VALUES
(1, 'Tarango Khan', '2015-07-19', 'QuickSort', 'Like Merge Sort, QuickSort is a Divide and Conquer algorithm.', '/* A typical recursive implementation of quick sort */\r\n#include<stdio.h>\r\n \r\n// A utility function to swap two elements\r\nvoid swap(int* a, int* b)\r\n{\r\n    int t = *a;\r\n    *a = *b;\r\n    *b = t;\r\n}\r\n \r\n/* This function takes last element as pivot, places the pivot element at its\r\n   correct position in sorted array, and places all smaller (smaller than pivot)\r\n   to left of pivot and all greater elements to right of pivot */\r\nint partition (int arr[], int l, int h)\r\n{\r\n    int x = arr[h];    // pivot\r\n    int i = (l - 1);  // Index of smaller element\r\n \r\n    for (int j = l; j <= h- 1; j++)\r\n    {\r\n        // If current element is smaller than or equal to pivot \r\n        if (arr[j] <= x)\r\n        {\r\n            i++;    // increment index of smaller element\r\n            swap(&arr[i], &arr[j]);  // Swap current element with index\r\n        }\r\n    }\r\n    swap(&arr[i + 1], &arr[h]);  \r\n    return (i + 1);\r\n}\r\n \r\n/* arr[] --> Array to be sorted, l  --> Starting index, h  --> Ending index */\r\nvoid quickSort(int arr[], int l, int h)\r\n{\r\n    if (l < h)\r\n    {\r\n        int p = partition(arr, l, h); /* Partitioning index */\r\n        quickSort(arr, l, p - 1);\r\n        quickSort(arr, p + 1, h);\r\n    }\r\n}\r\n \r\n/* Function to print an array */\r\nvoid printArray(int arr[], int size)\r\n{\r\n    int i;\r\n    for (i=0; i < size; i++)\r\n        printf("%d ", arr[i]);\r\n    printf("\\n");\r\n}\r\n \r\n// Driver program to test above functions\r\nint main()\r\n{\r\n    int arr[] = {10, 7, 8, 9, 1, 5};\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n    quickSort(arr, 0, n-1);\r\n    printf("Sorted array: \\n");\r\n    printArray(arr, n);\r\n    return 0;\r\n}', 'Like Merge Sort, QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways.\r\n1) Always pick first element as pivot.\r\n2) Always pick last element as pivot (implemented below)\r\n3) Pick a random element as pivot.\r\n4) Pick median as pivot.\r\nThe key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time.\r\nPartition Algorithm\r\nThere can be many ways to do partition, following code adopts the method given in CLRS book. The logic is simple, we start from the leftmost element and keep track of index of smaller (or equal to) elements as i. While traversing, if we find a smaller element, we swap current element with arr[i]. Otherwise we ignore current element.\r\nImplementation:\r\nFollowing is C++ implementation of QuickSort.', 'Analysis of QuickSort\r\nTime taken by QuickSort in general can be written as following.\r\n T(n) = T(k) + T(n-k-1) + \\theta(n)\r\nThe first two terms are for two recursive calls, the last term is for the partition process. k is the number of elements which are smaller than pivot.\r\nThe time taken by QuickSort depends upon the input array and partition strategy. Following are three cases.\r\nWorst Case: The worst case occurs when the partition process always picks greatest or smallest element as pivot. If we consider above partition strategy where last element is always picked as pivot, the worst case would occur when the array is already sorted in increasing or decreasing order. Following is recurrence for worst case.\r\n T(n) = T(0) + T(n-1) + \\theta(n)\r\nwhich is equivalent to  \r\n T(n) = T(n-1) + \\theta(n)\r\nThe solution of above recurrence is \\theta(n2).\r\nBest Case: The best case occurs when the partition process always picks the middle element as pivot. Following is recurrence for best case.\r\n T(n) = 2T(n/2) + \\theta(n)\r\nThe solution of above recurrence is \\theta(nLogn). It can be solved using case 2 of Master Theorem.\r\nAverage Case:\r\nTo do average case analysis, we need to consider all possible permutation of array and calculate time taken by every permutation which doesn’t look easy.\r\nWe can get an idea of average case by considering the case when partition puts O(n/9) elements in one set and O(9n/10) elements in other set. Following is recurrence for this case.\r\n T(n) = T(n/9) + T(9n/10) + \\theta(n)\r\nSolution of above recurrence is also O(nLogn)\r\nAlthough the worst case time complexity of QuickSort is O(n2) which is more than many other sorting algorithms like Merge Sort and Heap Sort, QuickSort is faster in practice, because its inner loop can be efficiently implemented on most architectures, and in most real-world data. QuickSort can be implemented in different ways by changing the choice of pivot, so that the worst case rarely occurs for a given type of data. However, merge sort is generally considered better when data is huge and stored in external storage.\r\nReferences:\r\nhttp://en.wikipedia.org/wiki/Quicksort\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\r\nCategory: Searching and Sorting', 'sorting', 'sort,data structure', 10),
(3, 'Tarango Khan', '2015-07-20', 'Heap Sort', 'Heap sort is a comparison based sorting technique based on Binary Heap data structure.', '// C implementation of Heap Sort\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n \r\n// A heap has current size and array of elements\r\nstruct MaxHeap\r\n{\r\n    int size;\r\n    int* array;\r\n};\r\n \r\n// A utility function to swap to integers\r\nvoid swap(int* a, int* b) { int t = *a; *a = *b;  *b = t; }\r\n \r\n// The main function to heapify a Max Heap. The function \r\n// assumes that everything under given root (element at \r\n// index idx) is already heapified\r\nvoid maxHeapify(struct MaxHeap* maxHeap, int idx)\r\n{\r\n    int largest = idx;  // Initialize largest as root\r\n    int left = (idx << 1) + 1;  // left = 2*idx + 1\r\n    int right = (idx + 1) << 1; // right = 2*idx + 2\r\n \r\n    // See if left child of root exists and is greater than\r\n    // root\r\n    if (left < maxHeap->size && \r\n        maxHeap->array[left] > maxHeap->array[largest])\r\n        largest = left;\r\n \r\n    // See if right child of root exists and is greater than\r\n    // the largest so far\r\n    if (right < maxHeap->size && \r\n        maxHeap->array[right] > maxHeap->array[largest])\r\n        largest = right;\r\n \r\n    // Change root, if needed\r\n    if (largest != idx)\r\n    {\r\n        swap(&maxHeap->array[largest], &maxHeap->array[idx]);\r\n        maxHeapify(maxHeap, largest);\r\n    }\r\n}\r\n \r\n// A utility function to create a max heap of given capacity\r\nstruct MaxHeap* createAndBuildHeap(int *array, int size)\r\n{\r\n    int i;\r\n    struct MaxHeap* maxHeap = \r\n              (struct MaxHeap*) malloc(sizeof(struct MaxHeap));\r\n    maxHeap->size = size;   // initialize size of heap\r\n    maxHeap->array = array; // Assign address of first element of array\r\n \r\n    // Start from bottommost and rightmost internal mode and heapify all\r\n    // internal modes in bottom up way\r\n    for (i = (maxHeap->size - 2) / 2; i >= 0; --i)\r\n        maxHeapify(maxHeap, i);\r\n    return maxHeap;\r\n}\r\n \r\n// The main function to sort an array of given size\r\nvoid heapSort(int* array, int size)\r\n{\r\n    // Build a heap from the input data.\r\n    struct MaxHeap* maxHeap = createAndBuildHeap(array, size);\r\n \r\n    // Repeat following steps while heap size is greater than 1. \r\n    // The last element in max heap will be the minimum element\r\n    while (maxHeap->size > 1)\r\n    {\r\n        // The largest item in Heap is stored at the root. Replace\r\n        // it with the last item of the heap followed by reducing the\r\n        // size of heap by 1.\r\n        swap(&maxHeap->array[0], &maxHeap->array[maxHeap->size - 1]);\r\n        --maxHeap->size;  // Reduce heap size\r\n \r\n        // Finally, heapify the root of tree.\r\n        maxHeapify(maxHeap, 0);\r\n    }\r\n}\r\n \r\n// A utility function to print a given array of given size\r\nvoid printArray(int* arr, int size)\r\n{\r\n    int i;\r\n    for (i = 0; i < size; ++i)\r\n        printf("%d ", arr[i]);\r\n}\r\n \r\n/* Driver program to test above functions */\r\nint main()\r\n{\r\n    int arr[] = {12, 11, 13, 5, 6, 7};\r\n    int size = sizeof(arr)/sizeof(arr[0]);\r\n \r\n    printf("Given array is \\n");\r\n    printArray(arr, size);\r\n \r\n    heapSort(arr, size);\r\n \r\n    printf("\\nSorted array is \\n");\r\n    printArray(arr, size);\r\n    return 0;\r\n}', 'Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end. We repeat the same process for remaining element.\r\nWhat is Binary Heap?\r\nLet us first define a Complete Binary Tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible (Source Wikipedia)\r\nA Binary Heap is a Complete Binary Tree where items are stored in a special order such that value in a parent node is greater(or smaller) than the values in its two children nodes. The former is called as max heap and the latter is called min heap. The heap can be represented by binary tree or array.\r\nWhy array based representation for Binary Heap?\r\nSince a Binary Heap is a Complete Binary Tree, it can be easily represented as array and array based representation is space efficient. If the parent node is stored at index I, the left child can be calculated by 2 * I + 1 and right child by 2 * I + 2.\r\nHeap Sort Algorithm for sorting in increasing order:\r\n1. Build a max heap from the input data.\r\n2. At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of tree.\r\n3. Repeat above steps until size of heap is greater than 1.\r\nHow to build the heap?\r\nHeapify procedure can be applied to a node only if its children nodes are heapified. So the heapification must be performed in the bottom up order.\r\nLets understand with the help of an example:\r\nInput data: 4, 10, 3, 5, 1\r\n                 4(0)\r\n		/   \\\r\n	     10(1)   3(2)\r\n            /   \\\r\n	 5(3)    1(4)\r\n\r\nThe numbers in bracket represent the indices in the array \r\nrepresentation of data.\r\n\r\nApplying heapify procedure to index 1:\r\n 		4(0)\r\n		/   \\\r\n            10(1)    3(2)\r\n           /   \\\r\n	5(3)    1(4)\r\n\r\nApplying heapify procedure to index 0:\r\n	        10(0)\r\n		/  \\\r\n	     5(1)  3(2)\r\n            /   \\\r\n         4(3)    1(4)\r\nThe heapify procedure calls itself recursively to build heap\r\n in top down manner.', 'Notes:\r\nHeap sort is an in-place algorithm.\r\nIts typical implementation is not stable, but can be made stable (See this)\r\nTime Complexity: Time complexity of heapify is O(Logn). Time complexity of createAndBuildHeap() is O(n) and overall time complexity of Heap Sort is O(nLogn).\r\nApplications of HeapSort\r\n1. Sort a nearly sorted (or K sorted) array\r\n2. k largest(or smallest) elements in an array\r\nHeap sort algorithm has limited uses because Quicksort and Mergesort are better in practice. Nevertheless, the Heap data structure itself is enormously used. See Applications of Heap Data Structure\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\r\nCategory: Searching and Sorting', 'sorting', 'sort,data structure', 10),
(4, 'Tarango Khan', '2015-07-20', 'Merge Sort', 'MergeSort is a Divide and Conquer algorithm. It divides input array in two halves', '/* C program for merge sort */\r\n#include<stdlib.h>\r\n#include<stdio.h>\r\n \r\n/* Function to merge the two haves arr[l..m] and arr[m+1..r] of array arr[] */\r\nvoid merge(int arr[], int l, int m, int r)\r\n{\r\n    int i, j, k;\r\n    int n1 = m - l + 1;\r\n    int n2 =  r - m;\r\n \r\n    /* create temp arrays */\r\n    int L[n1], R[n2];\r\n \r\n    /* Copy data to temp arrays L[] and R[] */\r\n    for(i = 0; i < n1; i++)\r\n        L[i] = arr[l + i];\r\n    for(j = 0; j < n2; j++)\r\n        R[j] = arr[m + 1+ j];\r\n \r\n    /* Merge the temp arrays back into arr[l..r]*/\r\n    i = 0;\r\n    j = 0;\r\n    k = l;\r\n    while (i < n1 && j < n2)\r\n    {\r\n        if (L[i] <= R[j])\r\n        {\r\n            arr[k] = L[i];\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            arr[k] = R[j];\r\n            j++;\r\n        }\r\n        k++;\r\n    }\r\n \r\n    /* Copy the remaining elements of L[], if there are any */\r\n    while (i < n1)\r\n    {\r\n        arr[k] = L[i];\r\n        i++;\r\n        k++;\r\n    }\r\n \r\n    /* Copy the remaining elements of R[], if there are any */\r\n    while (j < n2)\r\n    {\r\n        arr[k] = R[j];\r\n        j++;\r\n        k++;\r\n    }\r\n}\r\n \r\n/* l is for left index and r is right index of the sub-array\r\n  of arr to be sorted */\r\nvoid mergeSort(int arr[], int l, int r)\r\n{\r\n    if (l < r)\r\n    {\r\n        int m = l+(r-l)/2; //Same as (l+r)/2, but avoids overflow for large l and h\r\n        mergeSort(arr, l, m);\r\n        mergeSort(arr, m+1, r);\r\n        merge(arr, l, m, r);\r\n    }\r\n}\r\n \r\n \r\n/* UITLITY FUNCTIONS */\r\n/* Function to print an array */\r\nvoid printArray(int A[], int size)\r\n{\r\n    int i;\r\n    for (i=0; i < size; i++)\r\n        printf("%d ", A[i]);\r\n    printf("\\n");\r\n}\r\n \r\n/* Driver program to test above functions */\r\nint main()\r\n{\r\n    int arr[] = {12, 11, 13, 5, 6, 7};\r\n    int arr_size = sizeof(arr)/sizeof(arr[0]);\r\n \r\n    printf("Given array is \\n");\r\n    printArray(arr, arr_size);\r\n \r\n    mergeSort(arr, 0, arr_size - 1);\r\n \r\n    printf("\\nSorted array is \\n");\r\n    printArray(arr, arr_size);\r\n    return 0;\r\n}', 'MergeSort is a Divide and Conquer algorithm. It divides input array in two halves, calls itself for the two halves and then merges the two sorted halves. The merg() function is used for merging two halves. The merge(arr, l, m, r) is key process that assumes that arr[l..m] and arr[m+1..r] are sorted and merges the two sorted sub-arrays into one. See following C implementation for details.\r\nMergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', 'Time Complexity: Sorting arrays on different machines. Merge Sort is a recursive algorithm and time complexity can be expressed as following recurrence relation.\r\nT(n) = 2T(n/2) + \\Theta(n)\r\nThe above recurrence can be solved either using Recurrence Tree method or Master method. It falls in case II of Master Method and solution of the recurrence is \\Theta(nLogn).\r\nTime complexity of Merge Sort is \\Theta(nLogn) in all 3 cases (worst, average and best) as merge sort always divides the array in two halves and take linear time to merge two halves.\r\nAuxiliary Space: O(n)\r\nAlgorithmic Paradigm: Divide and Conquer\r\nSorting In Place: No in a typical implementation\r\nStable: Yes\r\nApplications of Merge Sort\r\n1) Merge Sort is useful for sorting linked lists in O(nLogn) time. Other nlogn algorithms like Heap Sort, Quick Sort (average case nLogn) cannot be applied to linked lists.\r\n2) Inversion Count Problem\r\n3) Used in External Sorting\r\n\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\r\nCategory: Searching and Sorting', 'sorting', 'sort,data structure', 10),
(5, 'Tarango Khan', '2015-07-21', 'Insertion Sort', 'Insertion sort is a simple sorting algorithm that works the way we sort playing cards in our hands.', '// C program for insertion sort\r\n#include <stdio.h>\r\n#include <math.h>\r\n \r\n/* Function to sort an array using insertion sort*/\r\nvoid insertionSort(int arr[], int n)\r\n{\r\n   int i, key, j;\r\n   for (i = 1; i < n; i++)\r\n   {\r\n       key = arr[i];\r\n       j = i-1;\r\n \r\n       /* Move elements of arr[0..i-1], that are\r\n          greater than key, to one position ahead\r\n          of their current position */\r\n       while (j >= 0 && arr[j] > key)\r\n       {\r\n           arr[j+1] = arr[j];\r\n           j = j-1;\r\n       }\r\n       arr[j+1] = key;\r\n   }\r\n}\r\n \r\n// A utility function ot print an array of size n\r\nvoid printArray(int arr[], int n)\r\n{\r\n   int i;\r\n   for (i=0; i < n; i++)\r\n       printf("%d ", arr[i]);\r\n   printf("\\n");\r\n}\r\n \r\n \r\n \r\n/* Driver program to test insertion sort */\r\nint main()\r\n{\r\n    int arr[] = {12, 11, 13, 5, 6};\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n \r\n    insertionSort(arr, n);\r\n    printArray(arr, n);\r\n \r\n    return 0;\r\n}', 'Algorithm\r\n// Sort an arr[] of size n\r\ninsertionSort(arr, n)\r\nLoop from i = 1 to n-1.\r\n……a) Pick element arr[i] and insert it into sorted sequence arr[0…i-1]\r\nExample: \r\n12, 11, 13, 5, 6\r\nLet us loop for i = 1 (second element of the array) to 5 (Size of input array)\r\ni = 1. Since 11 is smaller than 12, move 12 and insert 11 before 12\r\n11, 12, 13, 5, 6\r\ni = 2. 13 will remain at its position as all elements in A[0..I-1] are smaller than 13\r\n11, 12, 13, 5, 6\r\ni = 3. 5 will move to the beginning and all other elements from 11 to 13 will move one position ahead of their current position.\r\n5, 11, 12, 13, 6\r\ni = 4. 6 will move to position after 5, and elements from 11 to 13 will move one position ahead of their current position.\r\n5, 6, 11, 12, 13', 'Time Complexity: O(n*n)\r\nAuxiliary Space: O(1)\r\nBoundary Cases: Insertion sort takes maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted.\r\nAlgorithmic Paradigm: Incremental Approach\r\nSorting In Place: Yes\r\nStable: Yes\r\nOnline: Yes\r\nUses: Insertion sort is uses when number of elements is small. It can also be useful when input array is almost sorted, only few elements are misplaced in complete big array.\r\nQuizzes: Sorting Questions\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\r\nCategory: Searching and Sorting', 'sorting', 'sort,data structure', 10),
(6, 'Tarango Khan', '2015-07-21', 'Bubble Sort', 'Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.', '// C program for implementation of Bubble sort\r\n#include <stdio.h>\r\n \r\nvoid swap(int *xp, int *yp)\r\n{\r\n    int temp = *xp;\r\n    *xp = *yp;\r\n    *yp = temp;\r\n}\r\n \r\n// A function to implement bubble sort\r\nvoid bubbleSort(int arr[], int n)\r\n{\r\n   int i, j;\r\n   for (i = 0; i < n-1; i++)      \r\n       for (j = 0; j < n-i-1; j++) //Last i elements are already in place  \r\n           if (arr[j] > arr[j+1])\r\n              swap(&arr[j], &arr[j+1]);\r\n}\r\n \r\n/* Function to print an array */\r\nvoid printArray(int arr[], int size)\r\n{\r\n    int i;\r\n    for (i=0; i < size; i++)\r\n        printf("%d ", arr[i]);\r\n    printf("\\n");\r\n}\r\n \r\n// Driver program to test above functions\r\nint main()\r\n{\r\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n    bubbleSort(arr, n);\r\n    printf("Sorted array: \\n");\r\n    printArray(arr, n);\r\n    return 0;\r\n}\r\n\r\nOptimized Implementation:\r\nThe above function always runs O(n^2) time even if the array is sorted. It can be optimized by stopping the algorithm if inner loop didn’t cause any swap.\r\n// Optimized implementation of Bubble sort\r\n#include <stdio.h>\r\n \r\nvoid swap(int *xp, int *yp)\r\n{\r\n    int temp = *xp;\r\n    *xp = *yp;\r\n    *yp = temp;\r\n}\r\n \r\n// An optimized version of Bubble Sort\r\nvoid bubbleSort(int arr[], int n)\r\n{\r\n   int i, j;\r\n   bool swapped;\r\n   for (i = 0; i < n-1; i++)\r\n   {\r\n     swapped = false;\r\n     for (j = 0; j < n-i-1; j++)\r\n     {\r\n        if (arr[j] > arr[j+1])\r\n        {\r\n           swap(&arr[j], &arr[j+1]);\r\n           swapped = true;\r\n        }\r\n     }\r\n \r\n     // IF no two elements were swapped by inner loop, then break\r\n     if (swapped == false)\r\n        break;\r\n   }\r\n}\r\n \r\n/* Function to print an array */\r\nvoid printArray(int arr[], int size)\r\n{\r\n    int i;\r\n    for (i=0; i < size; i++)\r\n        printf("%d ", arr[i]);\r\n    printf("\\n");\r\n}\r\n \r\n// Driver program to test above functions\r\nint main()\r\n{\r\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n    bubbleSort(arr, n);\r\n    printf("Sorted array: \\n");\r\n    printArray(arr, n);\r\n    return 0;\r\n}', 'Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.\r\nExample:\r\nFirst Pass:\r\n( 5 1 4 2 8 ) –> ( 1 5 4 2 8 ), Here, algorithm compares the first two elements, and swaps since 5 > 1.\r\n( 1 5 4 2 8 ) –>  ( 1 4 5 2 8 ), Swap since 5 > 4\r\n( 1 4 5 2 8 ) –>  ( 1 4 2 5 8 ), Swap since 5 > 2\r\n( 1 4 2 5 8 ) –> ( 1 4 2 5 8 ), Now, since these elements are already in order (8 > 5), algorithm does not swap them.\r\nSecond Pass:\r\n( 1 4 2 5 8 ) –> ( 1 4 2 5 8 )\r\n( 1 4 2 5 8 ) –> ( 1 2 4 5 8 ), Swap since 4 > 2\r\n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )\r\n( 1 2 4 5 8 ) –>  ( 1 2 4 5 8 )\r\nNow, the array is already sorted, but our algorithm does not know if it is completed. The algorithm needs one whole pass without any swap to know it is sorted.\r\nThird Pass:\r\n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )\r\n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )\r\n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )\r\n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )', 'Time Complexity: O(n*n)\r\nAuxiliary Space: O(1)\r\nBoundary Cases: Bubble sort takes minimum time (Order of n) when elements are already sorted.\r\nSorting In Place: Yes\r\nStable: Yes\r\nDue to its simplicity, bubble sort is often used to introduce the concept of a sorting algorithm.\r\nIn computer graphics it is popular for its capability to detect a very small error (like swap of just two elements) in almost-sorted arrays and fix it with just linear complexity (2n). For example, it is used in a polygon filling algorithm, where bounding lines are sorted by their x coordinate at a specific scan line (a line parallel to x axis) and with incrementing y their order changes (two elements are swapped) only at intersections of two lines (Source: Wikipedia)\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above\r\nCategory: Searching and Sorting', 'sorting', 'sort,data structure', 10),
(7, 'Tarango Khan', '2015-07-21', 'Selection Sort', 'The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) ', '// C program for implementation of selection sort\r\n#include <stdio.h>\r\n \r\nvoid swap(int *xp, int *yp)\r\n{\r\n    int temp = *xp;\r\n    *xp = *yp;\r\n    *yp = temp;\r\n}\r\n \r\nvoid selectionSort(int arr[], int n)\r\n{\r\n    int i, j, min_idx;\r\n \r\n    // One by one move boundary of unsorted subarray\r\n    for (i = 0; i < n-1; i++)\r\n    {\r\n        // Find the minimum element in unsorted array\r\n        min_idx = i;\r\n        for (j = i+1; j < n; j++)\r\n          if (arr[j] < arr[min_idx])\r\n            min_idx = j;\r\n \r\n        // Swap the found minimum element with the first element\r\n        swap(&arr[min_idx], &arr[i]);\r\n    }\r\n}\r\n \r\n/* Function to print an array */\r\nvoid printArray(int arr[], int size)\r\n{\r\n    int i;\r\n    for (i=0; i < size; i++)\r\n        printf("%d ", arr[i]);\r\n    printf("\\n");\r\n}\r\n \r\n// Driver program to test above functions\r\nint main()\r\n{\r\n    int arr[] = {64, 25, 12, 22, 11};\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n    selectionSort(arr, n);\r\n    printf("Sorted array: \\n");\r\n    printArray(arr, n);\r\n    return 0;\r\n}', 'The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. The algorithm maintains two subarrays in a given array.\r\n1) The subarray which is already sorted.\r\n2) Remaining subarray which is unsorted.\r\nIn every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray.\r\nFollowing example explains the above steps:\r\narr[] = 64 25 12 22 11\r\n\r\n// Find the minimum element in arr[0...4] and place it at beginning\r\n11 25 12 22 64\r\n\r\n// Find the minimum element in arr[1...4] and \r\n// place it at beginning of arr[1...4]\r\n11 12 25 22 64\r\n\r\n// Find the minimum element in arr[2...4] and \r\n// place it at beginning of arr[2...4]\r\n11 12 22 25 64\r\n\r\n// Find the minimum element in arr[3...4] and \r\n// place it at beginning of arr[3...4]\r\n11 12 22 25 64 ', 'Time Complexity: O(n*n) as there are two nested loops.\r\nAuxiliary Space: O(1)\r\nThe good thing about selection sort is it never makes more than O(n) swaps and can be useful when memory write is a costly operation.\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above\r\nCategory: Searching and Sorting', 'sorting', 'sort,data structure', 10),
(8, 'Tarango Khan', '2015-07-21', 'Binary Search', 'Given a sorted array arr[] of n elements, write a function to search a given element x in arr[].', 'Following is Recursive C implementation of Binary Search.\r\n#include <stdio.h>\r\n \r\n// A recursive binary search function. It returns location of x in\r\n// given array arr[l..r] is present, otherwise -1\r\nint binarySearch(int arr[], int l, int r, int x)\r\n{\r\n   if (r >= l)\r\n   {\r\n        int mid = l + (r - l)/2;\r\n \r\n        // If the element is present at the middle itself\r\n        if (arr[mid] == x)  return mid;\r\n \r\n        // If element is smaller than mid, then it can only be present\r\n        // in left subarray\r\n        if (arr[mid] > x) return binarySearch(arr, l, mid-1, x);\r\n \r\n        // Else the element can only be present in right subarray\r\n        return binarySearch(arr, mid+1, r, x);\r\n   }\r\n \r\n   // We reach here when element is not present in array\r\n   return -1;\r\n}\r\n \r\nint main(void)\r\n{\r\n   int arr[] = {2, 3, 4, 10, 40};\r\n   int n = sizeof(arr)/ sizeof(arr[0]);\r\n   int x = 10;\r\n   int result = binarySearch(arr, 0, n-1, x);\r\n   (result == -1)? printf("Element is not present in array")\r\n                 : printf("Element is present at index %d", result);\r\n   return 0;\r\n}\r\n\r\nFollowing is Iterative C implementation of Binary Search.\r\n#include <stdio.h>\r\n \r\n// A iterative binary search function. It returns location of x in\r\n// given array arr[l..r] if present, otherwise -1\r\nint binarySearch(int arr[], int l, int r, int x)\r\n{\r\n  while (l <= r)\r\n  {\r\n    int m = l + (r-l)/2;\r\n \r\n    if (arr[m] == x) return m;  // Check if x is present at mid\r\n \r\n    if (arr[m] < x) l = m + 1; // If x greater, ignore left half\r\n \r\n    else r = m - 1; // If x is smaller, ignore right half\r\n  }\r\n  return -1; // if we reach here, then element was not present\r\n}\r\n \r\nint main(void)\r\n{\r\n   int arr[] = {2, 3, 4, 10, 40};\r\n   int n = sizeof(arr)/ sizeof(arr[0]);\r\n   int x = 10;\r\n   int result = binarySearch(arr, 0, n-1, x);\r\n   (result == -1)? printf("Element is not present in array")\r\n                 : printf("Element is present at index %d", result);\r\n   return 0;\r\n}', 'A simple approach is to do linear search, i.e., start from the leftmost element of arr[] and one by one compare x with each element of arr[], if x matches with an element, return the index. If x doesn’t match with any of elements, return -1.\r\n// Linearly search x in arr[].  If x is present then return its \r\n// location,  otherwise return -1\r\nint search(int arr[], int n, int x)\r\n{\r\n    int i;\r\n    for (i=0; i<n; i++)\r\n        if (arr[i] == x)\r\n         return i;\r\n    return -1;\r\n}\r\n\r\nThe time complexity of above algorithm is O(n).\r\nThe idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(Logn). We basically ignore half of the elements just after one comparison.\r\n1) Compare x with the middle element.\r\n2) If x matches with middle element, we return the mid index.\r\n3) Else If x is greater than the mid element, then x can only lie in right half subarray after the mid element. So we recur for right half.\r\n4) Else (x is smaller) recur for the left half.', 'Time Complexity:\r\nThe time complexity of Binary Search can be written as\r\nT(n) = T(n/2) + c \r\nThe above recurrence can be solved either using Recurrence T ree method or Master method. It falls in case II of Master Method and solution of the recurrence is \\Theta(Logn).\r\nAuxiliary Space: O(1) in case of iterative implementation. In case of recursive implementation, O(Logn) recursion call stack space.\r\nAlgorithmic Paradigm: Divide and Conquer\r\nFollowing are some interesting articles based on Binary Search.\r\nThe Ubiquitous Binary Search\r\nInterpolation search vs Binary search\r\nFind the minimum element in a sorted and rotated array\r\nFind a peak element\r\nFind a Fixed Point in a given array\r\nCount the number of occurrences in a sorted array\r\nMedian of two sorted arrays\r\nFloor and Ceiling in a sorted array\r\nFind the maximum element in an array which is first increasing and then decreasing\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\r\nCategory: Searching and Sorting', 'sorting', 'sort,data structure', 10),
(9, 'Tarango Khan', '2015-07-21', 'Greedy Algorithms | Set 2 (Kruskal’s Minimum Spanning Tree Algorithm)', 'Given a connected and undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the vertices together.', 'Since the number of edges included equals (V – 1), the algorithm stops here.\r\n\r\n// Kruskal''s algortihm to find Minimum Spanning Tree of a given connected,\r\n// undirected and weighted graph\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n \r\n// a structure to represent a weighted edge in graph\r\nstruct Edge\r\n{\r\n    int src, dest, weight;\r\n};\r\n \r\n// a structure to represent a connected, undirected and weighted graph\r\nstruct Graph\r\n{\r\n    // V-> Number of vertices, E-> Number of edges\r\n    int V, E;\r\n \r\n    // graph is represented as an array of edges. Since the graph is\r\n    // undirected, the edge from src to dest is also edge from dest\r\n    // to src. Both are counted as 1 edge here.\r\n    struct Edge* edge;\r\n};\r\n \r\n// Creates a graph with V vertices and E edges\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = (struct Graph*) malloc( sizeof(struct Graph) );\r\n    graph->V = V;\r\n    graph->E = E;\r\n \r\n    graph->edge = (struct Edge*) malloc( graph->E * sizeof( struct Edge ) );\r\n \r\n    return graph;\r\n}\r\n \r\n// A structure to represent a subset for union-find\r\nstruct subset\r\n{\r\n    int parent;\r\n    int rank;\r\n};\r\n \r\n// A utility function to find set of an element i\r\n// (uses path compression technique)\r\nint find(struct subset subsets[], int i)\r\n{\r\n    // find root and make root as parent of i (path compression)\r\n    if (subsets[i].parent != i)\r\n        subsets[i].parent = find(subsets, subsets[i].parent);\r\n \r\n    return subsets[i].parent;\r\n}\r\n \r\n// A function that does union of two sets of x and y\r\n// (uses union by rank)\r\nvoid Union(struct subset subsets[], int x, int y)\r\n{\r\n    int xroot = find(subsets, x);\r\n    int yroot = find(subsets, y);\r\n \r\n    // Attach smaller rank tree under root of high rank tree\r\n    // (Union by Rank)\r\n    if (subsets[xroot].rank < subsets[yroot].rank)\r\n        subsets[xroot].parent = yroot;\r\n    else if (subsets[xroot].rank > subsets[yroot].rank)\r\n        subsets[yroot].parent = xroot;\r\n \r\n    // If ranks are same, then make one as root and increment\r\n    // its rank by one\r\n    else\r\n    {\r\n        subsets[yroot].parent = xroot;\r\n        subsets[xroot].rank++;\r\n    }\r\n}\r\n \r\n// Compare two edges according to their weights.\r\n// Used in qsort() for sorting an array of edges\r\nint myComp(const void* a, const void* b)\r\n{\r\n    struct Edge* a1 = (struct Edge*)a;\r\n    struct Edge* b1 = (struct Edge*)b;\r\n    return a1->weight > b1->weight;\r\n}\r\n \r\n// The main function to construct MST using Kruskal''s algorithm\r\nvoid KruskalMST(struct Graph* graph)\r\n{\r\n    int V = graph->V;\r\n    struct Edge result[V];  // Tnis will store the resultant MST\r\n    int e = 0;  // An index variable, used for result[]\r\n    int i = 0;  // An index variable, used for sorted edges\r\n \r\n    // Step 1:  Sort all the edges in non-decreasing order of their weight\r\n    // If we are not allowed to change the given graph, we can create a copy of\r\n    // array of edges\r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\r\n \r\n    // Allocate memory for creating V ssubsets\r\n    struct subset *subsets =\r\n        (struct subset*) malloc( V * sizeof(struct subset) );\r\n \r\n    // Create V subsets with single elements\r\n    for (int v = 0; v < V; ++v)\r\n    {\r\n        subsets[v].parent = v;\r\n        subsets[v].rank = 0;\r\n    }\r\n \r\n    // Number of edges to be taken is equal to V-1\r\n    while (e < V - 1)\r\n    {\r\n        // Step 2: Pick the smallest edge. And increment the index\r\n        // for next iteration\r\n        struct Edge next_edge = graph->edge[i++];\r\n \r\n        int x = find(subsets, next_edge.src);\r\n        int y = find(subsets, next_edge.dest);\r\n \r\n        // If including this edge does''t cause cycle, include it\r\n        // in result and increment the index of result for next edge\r\n        if (x != y)\r\n        {\r\n            result[e++] = next_edge;\r\n            Union(subsets, x, y);\r\n        }\r\n        // Else discard the next_edge\r\n    }\r\n \r\n    // print the contents of result[] to display the built MST\r\n    printf("Following are the edges in the constructed MST\\n");\r\n    for (i = 0; i < e; ++i)\r\n        printf("%d -- %d == %d\\n", result[i].src, result[i].dest,\r\n                                                   result[i].weight);\r\n    return;\r\n}\r\n \r\n// Driver program to test above functions\r\nint main()\r\n{\r\n    /* Let us create following weighted graph\r\n             10\r\n        0--------1\r\n        |  \\     |\r\n       6|   5\\   |15\r\n        |      \\ |\r\n        2--------3\r\n            4       */\r\n    int V = 4;  // Number of vertices in graph\r\n    int E = 5;  // Number of edges in graph\r\n    struct Graph* graph = createGraph(V, E);\r\n \r\n \r\n    // add edge 0-1\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = 10;\r\n \r\n    // add edge 0-2\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 6;\r\n \r\n    // add edge 0-3\r\n    graph->edge[2].src = 0;\r\n    graph->edge[2].dest = 3;\r\n    graph->edge[2].weight = 5;\r\n \r\n    // add edge 1-3\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 15;\r\n \r\n    // add edge 2-3\r\n    graph->edge[4].src = 2;\r\n    graph->edge[4].dest = 3;\r\n    graph->edge[4].weight = 4;\r\n \r\n    KruskalMST(graph);\r\n \r\n    return 0;\r\n}', 'What is Minimum Spanning Tree?\r\nGiven a connected and undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the vertices together. A single graph can have many different spanning trees. A minimum spanning tree (MST) or minimum weight spanning tree for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree.\r\n\r\nHow many edges does a minimum spanning tree has?\r\nA minimum spanning tree has (V – 1) edges where V is the number of vertices in the given graph.\r\n\r\nWhat are the applications of Minimum Spanning Tree?\r\nSee this for applications of MST.\r\n\r\nBelow are the steps for finding MST using Kruskal’s algorithm\r\n\r\n1. Sort all the edges in non-decreasing order of their weight.\r\n\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree \r\nformed so far. If cycle is not formed, include this edge. Else, discard it.  \r\n\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.\r\nThe step#2 uses Union-Find algorithm to detect cycle. So we recommend to read following post as a prerequisite.\r\nUnion-Find Algorithm | Set 1 (Detect Cycle in a Graph)\r\nUnion-Find Algorithm | Set 2 (Union By Rank and Path Compression)', 'Time Complexity: O(ElogE) or O(ElogV). Sorting of edges takes O(ELogE) time. After sorting, we iterate through all edges and apply find-union algorithm. The find and union operations can take atmost O(LogV) time. So overall complexity is O(ELogE + ELogV) time. The value of E can be atmost V^2, so O(LogV) are O(LogE) same. Therefore, overall time complexity is O(ElogE) or O(ElogV)\r\n\r\nReferences:\r\nhttp://www.ics.uci.edu/~eppstein/161/960206.html\r\nhttp://en.wikipedia.org/wiki/Minimum_spanning_tree\r\n\r\nThis article is compiled by Aashish Barnwal and reviewed by GeeksforGeeks team. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Graph', 'Greedy,Graph,MST', 10);
INSERT INTO `algorithms` (`algo_id`, `author`, `date`, `title`, `short_note`, `code`, `description`, `analysis`, `category`, `tags`, `View`) VALUES
(10, 'Tarango Khan', '2015-07-21', 'Greedy Algorithms | Set 8 (Dijkstra’s Algorithm for Adjacency List Representation)', 'We have discussed Dijkstra’s algorithm and its implementation for adjacency matrix representation of graphs.', '// C / C++ program for Dijkstra''s shortest path algorithm for adjacency\r\n// list representation of graph\r\n \r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <limits.h>\r\n \r\n// A structure to represent a node in adjacency list\r\nstruct AdjListNode\r\n{\r\n    int dest;\r\n    int weight;\r\n    struct AdjListNode* next;\r\n};\r\n \r\n// A structure to represent an adjacency liat\r\nstruct AdjList\r\n{\r\n    struct AdjListNode *head;  // pointer to head node of list\r\n};\r\n \r\n// A structure to represent a graph. A graph is an array of adjacency lists.\r\n// Size of array will be V (number of vertices in graph)\r\nstruct Graph\r\n{\r\n    int V;\r\n    struct AdjList* array;\r\n};\r\n \r\n// A utility function to create a new adjacency list node\r\nstruct AdjListNode* newAdjListNode(int dest, int weight)\r\n{\r\n    struct AdjListNode* newNode =\r\n            (struct AdjListNode*) malloc(sizeof(struct AdjListNode));\r\n    newNode->dest = dest;\r\n    newNode->weight = weight;\r\n    newNode->next = NULL;\r\n    return newNode;\r\n}\r\n \r\n// A utility function that creates a graph of V vertices\r\nstruct Graph* createGraph(int V)\r\n{\r\n    struct Graph* graph = (struct Graph*) malloc(sizeof(struct Graph));\r\n    graph->V = V;\r\n \r\n    // Create an array of adjacency lists.  Size of array will be V\r\n    graph->array = (struct AdjList*) malloc(V * sizeof(struct AdjList));\r\n \r\n     // Initialize each adjacency list as empty by making head as NULL\r\n    for (int i = 0; i < V; ++i)\r\n        graph->array[i].head = NULL;\r\n \r\n    return graph;\r\n}\r\n \r\n// Adds an edge to an undirected graph\r\nvoid addEdge(struct Graph* graph, int src, int dest, int weight)\r\n{\r\n    // Add an edge from src to dest.  A new node is added to the adjacency\r\n    // list of src.  The node is added at the begining\r\n    struct AdjListNode* newNode = newAdjListNode(dest, weight);\r\n    newNode->next = graph->array[src].head;\r\n    graph->array[src].head = newNode;\r\n \r\n    // Since graph is undirected, add an edge from dest to src also\r\n    newNode = newAdjListNode(src, weight);\r\n    newNode->next = graph->array[dest].head;\r\n    graph->array[dest].head = newNode;\r\n}\r\n \r\n// Structure to represent a min heap node\r\nstruct MinHeapNode\r\n{\r\n    int  v;\r\n    int dist;\r\n};\r\n \r\n// Structure to represent a min heap\r\nstruct MinHeap\r\n{\r\n    int size;      // Number of heap nodes present currently\r\n    int capacity;  // Capacity of min heap\r\n    int *pos;     // This is needed for decreaseKey()\r\n    struct MinHeapNode **array;\r\n};\r\n \r\n// A utility function to create a new Min Heap Node\r\nstruct MinHeapNode* newMinHeapNode(int v, int dist)\r\n{\r\n    struct MinHeapNode* minHeapNode =\r\n           (struct MinHeapNode*) malloc(sizeof(struct MinHeapNode));\r\n    minHeapNode->v = v;\r\n    minHeapNode->dist = dist;\r\n    return minHeapNode;\r\n}\r\n \r\n// A utility function to create a Min Heap\r\nstruct MinHeap* createMinHeap(int capacity)\r\n{\r\n    struct MinHeap* minHeap =\r\n         (struct MinHeap*) malloc(sizeof(struct MinHeap));\r\n    minHeap->pos = (int *)malloc(capacity * sizeof(int));\r\n    minHeap->size = 0;\r\n    minHeap->capacity = capacity;\r\n    minHeap->array =\r\n         (struct MinHeapNode**) malloc(capacity * sizeof(struct MinHeapNode*));\r\n    return minHeap;\r\n}\r\n \r\n// A utility function to swap two nodes of min heap. Needed for min heapify\r\nvoid swapMinHeapNode(struct MinHeapNode** a, struct MinHeapNode** b)\r\n{\r\n    struct MinHeapNode* t = *a;\r\n    *a = *b;\r\n    *b = t;\r\n}\r\n \r\n// A standard function to heapify at given idx\r\n// This function also updates position of nodes when they are swapped.\r\n// Position is needed for decreaseKey()\r\nvoid minHeapify(struct MinHeap* minHeap, int idx)\r\n{\r\n    int smallest, left, right;\r\n    smallest = idx;\r\n    left = 2 * idx + 1;\r\n    right = 2 * idx + 2;\r\n \r\n    if (left < minHeap->size &&\r\n        minHeap->array[left]->dist < minHeap->array[smallest]->dist )\r\n      smallest = left;\r\n \r\n    if (right < minHeap->size &&\r\n        minHeap->array[right]->dist < minHeap->array[smallest]->dist )\r\n      smallest = right;\r\n \r\n    if (smallest != idx)\r\n    {\r\n        // The nodes to be swapped in min heap\r\n        MinHeapNode *smallestNode = minHeap->array[smallest];\r\n        MinHeapNode *idxNode = minHeap->array[idx];\r\n \r\n        // Swap positions\r\n        minHeap->pos[smallestNode->v] = idx;\r\n        minHeap->pos[idxNode->v] = smallest;\r\n \r\n        // Swap nodes\r\n        swapMinHeapNode(&minHeap->array[smallest], &minHeap->array[idx]);\r\n \r\n        minHeapify(minHeap, smallest);\r\n    }\r\n}\r\n \r\n// A utility function to check if the given minHeap is ampty or not\r\nint isEmpty(struct MinHeap* minHeap)\r\n{\r\n    return minHeap->size == 0;\r\n}\r\n \r\n// Standard function to extract minimum node from heap\r\nstruct MinHeapNode* extractMin(struct MinHeap* minHeap)\r\n{\r\n    if (isEmpty(minHeap))\r\n        return NULL;\r\n \r\n    // Store the root node\r\n    struct MinHeapNode* root = minHeap->array[0];\r\n \r\n    // Replace root node with last node\r\n    struct MinHeapNode* lastNode = minHeap->array[minHeap->size - 1];\r\n    minHeap->array[0] = lastNode;\r\n \r\n    // Update position of last node\r\n    minHeap->pos[root->v] = minHeap->size-1;\r\n    minHeap->pos[lastNode->v] = 0;\r\n \r\n    // Reduce heap size and heapify root\r\n    --minHeap->size;\r\n    minHeapify(minHeap, 0);\r\n \r\n    return root;\r\n}\r\n \r\n// Function to decreasy dist value of a given vertex v. This function\r\n// uses pos[] of min heap to get the current index of node in min heap\r\nvoid decreaseKey(struct MinHeap* minHeap, int v, int dist)\r\n{\r\n    // Get the index of v in  heap array\r\n    int i = minHeap->pos[v];\r\n \r\n    // Get the node and update its dist value\r\n    minHeap->array[i]->dist = dist;\r\n \r\n    // Travel up while the complete tree is not hepified.\r\n    // This is a O(Logn) loop\r\n    while (i && minHeap->array[i]->dist < minHeap->array[(i - 1) / 2]->dist)\r\n    {\r\n        // Swap this node with its parent\r\n        minHeap->pos[minHeap->array[i]->v] = (i-1)/2;\r\n        minHeap->pos[minHeap->array[(i-1)/2]->v] = i;\r\n        swapMinHeapNode(&minHeap->array[i],  &minHeap->array[(i - 1) / 2]);\r\n \r\n        // move to parent index\r\n        i = (i - 1) / 2;\r\n    }\r\n}\r\n \r\n// A utility function to check if a given vertex\r\n// ''v'' is in min heap or not\r\nbool isInMinHeap(struct MinHeap *minHeap, int v)\r\n{\r\n   if (minHeap->pos[v] < minHeap->size)\r\n     return true;\r\n   return false;\r\n}\r\n \r\n// A utility function used to print the solution\r\nvoid printArr(int dist[], int n)\r\n{\r\n    printf("Vertex   Distance from Source\\n");\r\n    for (int i = 0; i < n; ++i)\r\n        printf("%d \\t\\t %d\\n", i, dist[i]);\r\n}\r\n \r\n// The main function that calulates distances of shortest paths from src to all\r\n// vertices. It is a O(ELogV) function\r\nvoid dijkstra(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;// Get the number of vertices in graph\r\n    int dist[V];      // dist values used to pick minimum weight edge in cut\r\n \r\n    // minHeap represents set E\r\n    struct MinHeap* minHeap = createMinHeap(V);\r\n \r\n    // Initialize min heap with all vertices. dist value of all vertices \r\n    for (int v = 0; v < V; ++v)\r\n    {\r\n        dist[v] = INT_MAX;\r\n        minHeap->array[v] = newMinHeapNode(v, dist[v]);\r\n        minHeap->pos[v] = v;\r\n    }\r\n \r\n    // Make dist value of src vertex as 0 so that it is extracted first\r\n    minHeap->array[src] = newMinHeapNode(src, dist[src]);\r\n    minHeap->pos[src]   = src;\r\n    dist[src] = 0;\r\n    decreaseKey(minHeap, src, dist[src]);\r\n \r\n    // Initially size of min heap is equal to V\r\n    minHeap->size = V;\r\n \r\n    // In the followin loop, min heap contains all nodes\r\n    // whose shortest distance is not yet finalized.\r\n    while (!isEmpty(minHeap))\r\n    {\r\n        // Extract the vertex with minimum distance value\r\n        struct MinHeapNode* minHeapNode = extractMin(minHeap);\r\n        int u = minHeapNode->v; // Store the extracted vertex number\r\n \r\n        // Traverse through all adjacent vertices of u (the extracted\r\n        // vertex) and update their distance values\r\n        struct AdjListNode* pCrawl = graph->array[u].head;\r\n        while (pCrawl != NULL)\r\n        {\r\n            int v = pCrawl->dest;\r\n \r\n            // If shortest distance to v is not finalized yet, and distance to v\r\n            // through u is less than its previously calculated distance\r\n            if (isInMinHeap(minHeap, v) && dist[u] != INT_MAX && \r\n                                          pCrawl->weight + dist[u] < dist[v])\r\n            {\r\n                dist[v] = dist[u] + pCrawl->weight;\r\n \r\n                // update distance value in min heap also\r\n                decreaseKey(minHeap, v, dist[v]);\r\n            }\r\n            pCrawl = pCrawl->next;\r\n        }\r\n    }\r\n \r\n    // print the calculated shortest distances\r\n    printArr(dist, V);\r\n}\r\n \r\n \r\n// Driver program to test above functions\r\nint main()\r\n{\r\n    // create the graph given in above fugure\r\n    int V = 9;\r\n    struct Graph* graph = createGraph(V);\r\n    addEdge(graph, 0, 1, 4);\r\n    addEdge(graph, 0, 7, 8);\r\n    addEdge(graph, 1, 2, 8);\r\n    addEdge(graph, 1, 7, 11);\r\n    addEdge(graph, 2, 3, 7);\r\n    addEdge(graph, 2, 8, 2);\r\n    addEdge(graph, 2, 5, 4);\r\n    addEdge(graph, 3, 4, 9);\r\n    addEdge(graph, 3, 5, 14);\r\n    addEdge(graph, 4, 5, 10);\r\n    addEdge(graph, 5, 6, 2);\r\n    addEdge(graph, 6, 7, 1);\r\n    addEdge(graph, 6, 8, 6);\r\n    addEdge(graph, 7, 8, 7);\r\n \r\n    dijkstra(graph, 0);\r\n \r\n    return 0;\r\n}\r\n', 'We have discussed Dijkstra’s algorithm and its implementation for adjacency matrix representation of graphs. The time complexity for the matrix representation is O(V^2). In this post, O(ELogV) algorithm for adjacency list representation is discussed.\r\n\r\nAs discussed in the previous post, in Dijkstra’s algorithm, two sets are maintained, one set contains list of vertices already included in SPT (Shortest Path Tree), other set contains vertices not yet included. With adjacency list representation, all vertices of a graph can be traversed in O(V+E) time using BFS. The idea is to traverse all vertices of graph using BFS and use a Min Heap to store the vertices not yet included in SPT (or the vertices for which shortest distance is not finalized yet).  Min Heap is used as a priority queue to get the minimum distance vertex from set of not yet included vertices. Time complexity of operations like extract-min and decrease-key value is O(LogV) for Min Heap.\r\n\r\nFollowing are the detailed steps.\r\n1) Create a Min Heap of size V where V is the number of vertices in the given graph. Every node of min heap contains vertex number and distance value of the vertex.\r\n2) Initialize Min Heap with source vertex as root (the distance value assigned to source vertex is 0). The distance value assigned to all other vertices is INF (infinite).\r\n3) While Min Heap is not empty, do following\r\n…..a) Extract the vertex with minimum distance value node from Min Heap. Let the extracted vertex be u.\r\n…..b) For every adjacent vertex v of u, check if v is in Min Heap. If v is in Min Heap and distance value is more than weight of u-v plus distance value of u, then update the distance value of v.', 'Time Complexity: The time complexity of the above code/algorithm looks O(V^2) as there are two nested while loops. If we take a closer look, we can observe that the statements in inner loop are executed O(V+E) times (similar to BFS). The inner loop has decreaseKey() operation which takes O(LogV) time. So overall time complexity is O(E+V)*O(LogV) which is O((E+V)*LogV) = O(ELogV)\r\nNote that the above code uses Binary Heap for Priority Queue implementation. Time complexity can be reduced to O(E + VLogV) using Fibonacci Heap. The reason is, Fibonacci Heap takes O(1) time for decrease-key operation while Binary Heap takes O(Logn) time.\r\n\r\nNotes:\r\n1) The code calculates shortest distance, but doesn’t calculate the path information. We can create a parent array, update the parent array when distance is updated (like prim’s implementation) and use it show the shortest path from source to different vertices.\r\n\r\n2) The code is for undirected graph, same dijekstra function can be used for directed graphs also.\r\n\r\n3) The code finds shortest distances from source to all vertices. If we are interested only in shortest distance from source to a single target, we can break the for loop when the picked minimum distance vertex is equal to target (Step 3.a of algorithm).\r\n\r\n4) Dijkstra’s algorithm doesn’t work for graphs with negative weight edges. For graphs with negative weight edges, Bellman–Ford algorithm can be used, we will soon be discussing it as a separate post.\r\n\r\nReferences:\r\nIntroduction to Algorithms by Clifford Stein, Thomas H. Cormen, Charles E. Leiserson, Ronald L.\r\nAlgorithms by Sanjoy Dasgupta, Christos Papadimitriou, Umesh Vazirani\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Graph', 'Graph,Shortest Path,Greedy', 10),
(11, 'Tarango Khan', '2015-07-21', 'Greedy Algorithms | Set 5 (Prim’s Minimum Spanning Tree (MST))', 'We have discussed Kruskal’s algorithm for Minimum Spanning Tree. Like Kruskal’s algorithm, Prim’s algorithm is also a Greedy algorithm.', 'How to implement the above algorithm?\r\nWe use a boolean array mstSet[] to represent the set of vertices included in MST. If a value mstSet[v] is true, then vertex v is included in MST, otherwise not. Array key[] is used to store key values of all vertices. Another array parent[] to store indexes of parent nodes in MST. The parent array is the output array which is used to show the constructed MST.\r\n\r\n// A C / C++ program for Prim''s Minimum Spanning Tree (MST) algorithm. \r\n// The program is for adjacency matrix representation of the graph\r\n \r\n#include <stdio.h>\r\n#include <limits.h>\r\n \r\n// Number of vertices in the graph\r\n#define V 5\r\n \r\n// A utility function to find the vertex with minimum key value, from\r\n// the set of vertices not yet included in MST\r\nint minKey(int key[], bool mstSet[])\r\n{\r\n   // Initialize min value\r\n   int min = INT_MAX, min_index;\r\n \r\n   for (int v = 0; v < V; v++)\r\n     if (mstSet[v] == false && key[v] < min)\r\n         min = key[v], min_index = v;\r\n \r\n   return min_index;\r\n}\r\n \r\n// A utility function to print the constructed MST stored in parent[]\r\nint printMST(int parent[], int n, int graph[V][V])\r\n{\r\n   printf("Edge   Weight\\n");\r\n   for (int i = 1; i < V; i++)\r\n      printf("%d - %d    %d \\n", parent[i], i, graph[i][parent[i]]);\r\n}\r\n \r\n// Function to construct and print MST for a graph represented using adjacency\r\n// matrix representation\r\nvoid primMST(int graph[V][V])\r\n{\r\n     int parent[V]; // Array to store constructed MST\r\n     int key[V];   // Key values used to pick minimum weight edge in cut\r\n     bool mstSet[V];  // To represent set of vertices not yet included in MST\r\n \r\n     // Initialize all keys as INFINITE\r\n     for (int i = 0; i < V; i++)\r\n        key[i] = INT_MAX, mstSet[i] = false;\r\n \r\n     // Always include first 1st vertex in MST.\r\n     key[0] = 0;     // Make key 0 so that this vertex is picked as first vertex\r\n     parent[0] = -1; // First node is always root of MST \r\n \r\n     // The MST will have V vertices\r\n     for (int count = 0; count < V-1; count++)\r\n     {\r\n        // Pick thd minimum key vertex from the set of vertices\r\n        // not yet included in MST\r\n        int u = minKey(key, mstSet);\r\n \r\n        // Add the picked vertex to the MST Set\r\n        mstSet[u] = true;\r\n \r\n        // Update key value and parent index of the adjacent vertices of\r\n        // the picked vertex. Consider only those vertices which are not yet\r\n        // included in MST\r\n        for (int v = 0; v < V; v++)\r\n \r\n           // graph[u][v] is non zero only for adjacent vertices of m\r\n           // mstSet[v] is false for vertices not yet included in MST\r\n           // Update the key only if graph[u][v] is smaller than key[v]\r\n          if (graph[u][v] && mstSet[v] == false && graph[u][v] <  key[v])\r\n             parent[v]  = u, key[v] = graph[u][v];\r\n     }\r\n \r\n     // print the constructed MST\r\n     printMST(parent, V, graph);\r\n}\r\n \r\n \r\n// driver program to test above function\r\nint main()\r\n{\r\n   /* Let us create the following graph\r\n          2    3\r\n      (0)--(1)--(2)\r\n       |   / \\   |\r\n      6| 8/   \\5 |7\r\n       | /     \\ |\r\n      (3)-------(4)\r\n            9          */\r\n   int graph[V][V] = {{0, 2, 0, 6, 0},\r\n                      {2, 0, 3, 8, 5},\r\n                      {0, 3, 0, 0, 7},\r\n                      {6, 8, 0, 0, 9},\r\n                      {0, 5, 7, 9, 0},\r\n                     };\r\n \r\n    // Print the solution\r\n    primMST(graph);\r\n \r\n    return 0;\r\n}', 'We have discussed Kruskal’s algorithm for Minimum Spanning Tree. Like Kruskal’s algorithm, Prim’s algorithm is also a Greedy algorithm. It starts with an empty spanning tree. The idea is to maintain two sets of vertices. The first set contains the vertices already included in the MST, the other set contains the vertices not yet included. At every step, it considers all the edges that connect the two sets, and picks the minimum weight edge from these edges. After picking the edge, it moves the other endpoint of the edge to the set containing MST.\r\nA group of edges that connects two set of vertices in a graph is called cut in graph theory. So, at every step of Prim’s algorithm, we find a cut (of two sets, one contains the vertices already included in MST and other contains rest of the verices), pick the minimum weight edge from the cut and include this vertex to MST Set (the set that contains already included vertices).\r\n\r\nHow does Prim’s Algorithm Work? The idea behind Prim’s algorithm is simple, a spanning tree means all vertices must be connected. So the two disjoint subsets (discussed above) of vertices must be connected to make a Spanning Tree. And they must be connected with the minimum weight edge to make it a Minimum Spanning Tree.\r\n\r\nAlgorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v\r\n\r\nThe idea of using key values is to pick the minimum weight edge from cut. The key values are used only for vertices which are not yet included in MST, the key value for these vertices indicate the minimum weight edges connecting them to the set of vertices included in MST.', 'Time Complexity of the above program is O(V^2). If the input graph is represented using adjacency list, then the time complexity of Prim’s algorithm can be reduced to O(E log V) with the help of binary heap. We will soon be discussing O(E Log V) algorithm as a separate post.\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Graph', 'Graph,Greedy,MST', 10),
(12, 'Tarango Khan', '2015-07-21', 'Greedy Algorithms | Set 1 (Activity Selection Problem)', 'Greedy is an algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit.', 'In the following C implementation, it is assumed that the activities are already sorted according to their finish time.\r\n\r\n#include<stdio.h>\r\n \r\n// Prints a maximum set of activities that can be done by a single\r\n// person, one at a time.\r\n//  n   -->  Total number of activities\r\n//  s[] -->  An array that contains start time of all activities\r\n//  f[] -->  An array that contains finish time of all activities\r\nvoid printMaxActivities(int s[], int f[], int n)\r\n{\r\n    int i, j;\r\n \r\n    printf ("Following activities are selected \\n");\r\n \r\n    // The first activity always gets selected\r\n    i = 0;\r\n    printf("%d ", i);\r\n \r\n    // Consider rest of the activities\r\n    for (j = 1; j < n; j++)\r\n    {\r\n      // If this activity has start time greater than or equal to the finish\r\n      // time of previously selected activity, then select it\r\n      if (s[j] >= f[i])\r\n      {\r\n          printf ("%d ", j);\r\n          i = j;\r\n      }\r\n    }\r\n}\r\n \r\n// driver program to test above function\r\nint main()\r\n{\r\n    int s[] =  {1, 3, 0, 5, 8, 5};\r\n    int f[] =  {2, 4, 6, 7, 9, 9};\r\n    int n = sizeof(s)/sizeof(s[0]);\r\n    printMaxActivities(s, f, n);\r\n    getchar();\r\n    return 0;\r\n}', 'Greedy is an algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit. Greedy algorithms are used for optimization problems. An optimization problem can be solved using Greedy if the problem has the following property: At every step, we can make a choice that looks best at the moment, and we get the optimal solution of the complete problem.\r\nIf a Greedy Algorithm can solve a problem, then it generally becomes the best method to solve that problem as the Greedy algorithms are in general more efficient than other techniques like Dynamic Programming. But Greedy algorithms cannot always be applied. For example, Fractional Knapsack problem (See this) can be solved using Greedy, but 0-1 Knapsack cannot be solved using Greedy.\r\n\r\nFollowing are some standard algorithms that are Greedy algorithms.\r\n1) Kruskal’s Minimum Spanning Tree (MST): In Kruskal’s algorithm, we create a MST by picking edges one by one. The Greedy Choice is to pick the smallest weight edge that doesn’t cause a cycle in the MST constructed so far.\r\n2) Prim’s Minimum Spanning Tree: In Prim’s algorithm also, we create a MST by picking edges one by one. We maintain two sets: set of the vertices already included in MST and the set of the vertices not yet included. The Greedy Choice is to pick the smallest weight edge that connects the two sets.\r\n3) Dijkstra’s Shortest Path: The Dijkstra’s algorithm is very similar to Prim’s algorithm. The shortest path tree is built up, edge by edge. We maintain two sets: set of the vertices already included in the tree and the set of the vertices not yet included. The Greedy Choice is to pick the edge that connects the two sets and is on the smallest weight path from source to the set that contains not yet included vertices.\r\n4) Huffman Coding: Huffman Coding is a loss-less compression technique. It assigns variable length bit codes to different characters. The Greedy Choice is to assign least bit length code to the most frequent character.\r\n\r\nThe greedy algorithms are sometimes also used to get an approximation for Hard optimization problems. For example, Traveling Salesman Problem is a NP Hard problem. A Greedy choice for this problem is to pick the nearest unvisited city from the current city at every step. This solutions doesn’t always produce the best optimal solution, but can be used to get an approximate optimal solution.\r\n\r\nLet us consider the Activity Selection problem as our first example of Greedy algorithms. Following is the problem statement.\r\nYou are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person, assuming that a person can only work on a single activity at a time.\r\nExample:\r\n\r\nConsider the following 6 activities. \r\n     start[]  =  {1, 3, 0, 5, 8, 5};\r\n     finish[] =  {2, 4, 6, 7, 9, 9};\r\nThe maximum set of activities that can be executed \r\nby a single person is {0, 1, 3, 4}\r\nThe greedy choice is to always pick the next activity whose finish time is least among the remaining activities and the start time is more than or equal to the finish time of previously selected activity. We can sort the activities according to their finishing time so that we always consider the next activity as minimum finishing time activity.\r\n\r\n1) Sort the activities according to their finishing time\r\n2) Select the first activity from the sorted array and print it.\r\n3) Do following for remaining activities in the sorted array.\r\n…….a) If the start time of this activity is greater than the finish time of previously selected activity then select this activity and print it.', 'How does Greedy Choice work for Activities sorted according to finish time?\r\nLet the give set of activities be S = {1, 2, 3, ..n} and activities be sorted by finish time. The greedy choice is to always pick activity 1. How come the activity 1 always provides one of the optimal solutions. We can prove it by showing that if there is another solution B with first activity other than 1, then there is also a solution A of same size with activity 1 as first activity. Let the first activity selected by B be k, then there always exist A = {B – {k}} U {1}.(Note that the activities in B are independent and k has smallest finishing time among all. Since k is not 1, finish(k) >= finish(1)).\r\n\r\nReferences:\r\nIntroduction to Algorithms by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein\r\nAlgorithms by S. Dasgupta, C.H. Papadimitriou, and U.V. Vazirani \r\nhttp://en.wikipedia.org/wiki/Greedy_algorithm\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Greedy', 'Greedy', 10),
(13, 'Tarango Khan', '2015-07-21', 'Job Sequencing Problem | Set 1 (Greedy Algorithm)', 'Given an array of jobs where every job has a deadline and associated profit if the job is finished before the deadline.', 'The Following is C++ implementation of above algorithm.\r\n\r\n// Program to find the maximum profit job sequence from a given array\r\n// of jobs with deadlines and profits\r\n#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n// A structure to represent a job\r\nstruct Job\r\n{\r\n   char id;      // Job Id\r\n   int dead;    // Deadline of job\r\n   int profit;  // Profit if job is over before or on deadline\r\n};\r\n \r\n// This function is used for sorting all jobs according to profit\r\nbool comparison(Job a, Job b)\r\n{\r\n     return (a.profit > b.profit);\r\n}\r\n \r\n// Returns minimum number of platforms reqquired\r\nvoid printJobScheduling(Job arr[], int n)\r\n{\r\n    // Sort all jobs according to decreasing order of prfit\r\n    sort(arr, arr+n, comparison);\r\n \r\n    int result[n]; // To store result (Sequence of jobs)\r\n    bool slot[n];  // To keep track of free time slots\r\n \r\n    // Initialize all slots to be free\r\n    for (int i=0; i<n; i++)\r\n        slot[i] = false;\r\n \r\n    // Iterate through all given jobs\r\n    for (int i=0; i<n; i++)\r\n    {\r\n       // Find a free slot for this job (Note that we start\r\n       // from the last possible slot)\r\n       for (int j=min(n, arr[i].dead)-1; j>=0; j--)\r\n       {\r\n          // Free slot found\r\n          if (slot[j]==false)\r\n          {\r\n             result[j] = i;  // Add this job to result\r\n             slot[j] = true; // Make this slot occupied\r\n             break;\r\n          }\r\n       }\r\n    }\r\n \r\n    // Print the result\r\n    for (int i=0; i<n; i++)\r\n       if (slot[i])\r\n         cout << arr[result[i]].id << " ";\r\n}\r\n \r\n// Driver program to test methods\r\nint main()\r\n{\r\n    Job arr[5] = { {''a'', 2, 100}, {''b'', 1, 19}, {''c'', 2, 27},\r\n                   {''d'', 1, 25}, {''e'', 3, 15}};\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n    cout << "Following is maximum profit sequence of jobs\\n";\r\n    printJobScheduling(arr, n);\r\n    return 0;\r\n}', 'Given an array of jobs where every job has a deadline and associated profit if the job is finished before the deadline. It is also given that every job takes single unit of time, so the minimum possible deadline for any job is 1. How to maximize total profit if only one job can be scheduled at a time.\r\n\r\nExamples:\r\n\r\nInput: Four Jobs with following deadlines and profits\r\n  JobID    Deadline      Profit\r\n    a        4            20   \r\n    b        1            10\r\n    c        1            40  \r\n    d        1            30\r\nOutput: Following is maximum profit sequence of jobs\r\n        c, a   \r\n\r\n\r\nInput:  Five Jobs with following deadlines and profits\r\n   JobID     Deadline     Profit\r\n     a         2           100\r\n     b         1           19\r\n     c         2           27\r\n     d         1           25\r\n     e         3           15\r\nOutput: Following is maximum profit sequence of jobs\r\n        c, a, e\r\nWe strongly recommend to minimize your browser and try this yourself first.\r\n\r\nA Simple Solution is to generate all subsets of given set of jobs and check individual subset for feasibility of jobs in that subset. Keep track of maximum profit among all feasible subsets. The time complexity of this solution is exponential.\r\n\r\nThis is a standard Greedy Algorithm problem. Following is algorithm.\r\n\r\n1) Sort all jobs in decreasing order of profit.\r\n2) Initialize the result sequence as first job in sorted jobs.\r\n3) Do following for remaining n-1 jobs\r\n.......a) If the current job can fit in the current result sequence \r\n          without missing the deadline, add current job to the result.\r\n          Else ignore the current job.', 'Time Complexity of the above solution is O(n2). It can be optimized to almost O(n) by using union-find data structure. We will son be discussing the optimized solution.\r\n\r\nSources:\r\nhttp://ocw.mit.edu/courses/civil-and-environmental-engineering/1-204-computer-algorithms-in-systems-engineering-spring-2010/lecture-notes/MIT1_204S10_lec10.pdf\r\n\r\nThis article is contributed by Shubham. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Greedy', 'Greedy', 10),
(14, 'Tarango Khan', '2015-07-22', 'Dynamic Programming | Set 1 (Overlapping Subproblems Property)', 'Dynamic Programming is an algorithmic paradigm that solves a given complex problem by breaking it into subproblems', 'Following is the memoized version for nth Fibonacci Number.\r\n\r\n/* Memoized version for nth Fibonacci number */\r\n#include<stdio.h>\r\n#define NIL -1\r\n#define MAX 100\r\n \r\nint lookup[MAX];\r\n \r\n/* Function to initialize NIL values in lookup table */\r\nvoid _initialize()\r\n{\r\n  int i;\r\n  for (i = 0; i < MAX; i++)\r\n    lookup[i] = NIL;\r\n}\r\n \r\n/* function for nth Fibonacci number */\r\nint fib(int n)\r\n{\r\n   if(lookup[n] == NIL)\r\n   {\r\n    if ( n <= 1 )\r\n      lookup[n] = n;\r\n    else\r\n      lookup[n] = fib(n-1) + fib(n-2);\r\n   }\r\n \r\n   return lookup[n];\r\n}\r\n \r\nint main ()\r\n{\r\n  int n = 40;\r\n  _initialize();\r\n  printf("Fibonacci number is %d ", fib(n));\r\n  getchar();\r\n  return 0;\r\n}\r\n\r\nb) Tabulation (Bottom Up): The tabulated program for a given problem builds a table in bottom up fashion and returns the last entry from table.\r\n\r\n/* tabulated version */\r\n#include<stdio.h>\r\nint fib(int n)\r\n{\r\n  int f[n+1];\r\n  int i;\r\n  f[0] = 0;   f[1] = 1; \r\n  for (i = 2; i <= n; i++)\r\n      f[i] = f[i-1] + f[i-2];\r\n \r\n  return f[n];\r\n}\r\n  \r\nint main ()\r\n{\r\n  int n = 9;\r\n  printf("Fibonacci number is %d ", fib(n));\r\n  getchar();\r\n  return 0;\r\n}', 'Dynamic Programming is an algorithmic paradigm that solves a given complex problem by breaking it into subproblems and stores the results of subproblems to avoid computing the same results again. Following are the two main properties of a problem that suggest that the given problem can be solved using Dynamic programming.\r\n\r\n1) Overlapping Subproblems\r\n2) Optimal Substructure\r\n\r\n1) Overlapping Subproblems:\r\nLike Divide and Conquer, Dynamic Programming combines solutions to sub-problems. Dynamic Programming is mainly used when solutions of same subproblems are needed again and again. In dynamic programming, computed solutions to subproblems are stored in a table so that these don’t have to recomputed. So Dynamic Programming is not useful when there are no common (overlapping) subproblems because there is no point storing the solutions if they are not needed again. For example, Binary Search doesn’t have common subproblems. If we take example of following recursive program for Fibonacci Numbers, there are many subproblems which are solved again and again.\r\nWe can see that the function f(3) is being called 2 times. If we would have stored the value of f(3), then instead of computing it again, we would have reused the old stored value. There are following two different ways to store the values so that these values can be reused.\r\n\r\na) Memoization (Top Down): \r\nb) Tabulation (Bottom Up):\r\n\r\na) Memoization (Top Down): The memoized program for a problem is similar to the recursive version with a small modification that it looks into a lookup table before computing solutions. We initialize a lookup array with all initial values as NIL. Whenever we need solution to a subproblem, we first look into the lookup table. If the precomputed value is there then we return that value, otherwise we calculate the value and put the result in lookup table so that it can be reused later.', 'Both tabulated and Memoized store the solutions of subproblems. In Memoized version, table is filled on demand while in tabulated version, starting from the first entry, all entries are filled one by one. Unlike the tabulated version, all entries of the lookup table are not necessarily filled in memoized version. For example, memoized solution of LCS problem doesn’t necessarily fill all entries.\r\n\r\nTo see the optimization achieved by memoized and tabulated versions over the basic recursive version, see the time taken by following runs for 40th Fibonacci number.\r\n\r\nSimple recursive program\r\nMemoized version\r\ntabulated version\r\n\r\nAlso see method 2 of Ugly Number post for one more simple example where we have overlapping subproblems and we store the results of subproblems.\r\n\r\nWe will be covering Optimal Substructure Property and some more example problems in future posts on Dynamic Programming.\r\n\r\nTry following questions as an exercise of this post.\r\n1) Write a memoized version for LCS problem. Note that the tabular version is given in the CLRS book.\r\n2) How would you choose between Memoization and Tabulation?\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\r\n\r\nReferences:\r\nhttp://www.youtube.com/watch?v=V5hZoJ6uK-s', 'Dynamic Programming', 'DP', 10),
(15, 'Tarango Khan', '2015-07-22', 'Dynamic Programming | Set 2 (Optimal Substructure Property)', 'As we discussed in Set 1, following are the two main properties of a problem that suggest that the given problem can be solved using Dynamic programming.', '', 'As we discussed in Set 1, following are the two main properties of a problem that suggest that the given problem can be solved using Dynamic programming.\r\n\r\n1) Overlapping Subproblems\r\n2) Optimal Substructure\r\n\r\nWe have already discussed Overlapping Subproblem property in the Set 1. Let us discuss Optimal Substructure property here.\r\n\r\n2) Optimal Substructure: A given problems has Optimal Substructure Property if optimal solution of the given problem can be obtained by using optimal solutions of its subproblems.\r\nFor example the shortest path problem has following optimal substructure property: If a node x lies in the shortest path from a source node u to destination node v then the shortest path from u to v is combination of shortest path from u to x and shortest path from x to v. The standard All Pair Shortest Path algorithms like Floyd–Warshall and Bellman–Ford are typical examples of Dynamic Programming.\r\nOn the other hand the Longest path problem doesn’t have the Optimal Substructure property. Here by Longest Path we mean longest simple path (path without cycle) between two nodes. Consider the following unweighted graph given in the CLRS book. There are two longest paths from q to t: q -> r ->t and q ->s->t. Unlike shortest paths, these longest paths do not have the optimal substructure property. For example, the longest path q->r->t is not a combination of longest path from q to r and longest path from r to t, because the longest path from q to r is q->s->t->r.', 'We will be covering some example problems in future posts on Dynamic Programming.\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\r\n\r\nReferences:\r\nhttp://en.wikipedia.org/wiki/Optimal_substructure\r\nCLRS book', 'Dynamic Programming', 'DP', 10),
(16, '', '0000-00-00', 'Dynamic Programming | Set 3 (Longest Increasing Subsequence)', 'We have discussed Overlapping Subproblems and Optimal Substructure properties in Set 1 and Set 2 respectively.', '/* A Naive recursive implementation of LIS problem */\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n \r\n/* To make use of recursive calls, this function must return two things:\r\n   1) Length of LIS ending with element arr[n-1]. We use max_ending_here \r\n      for this purpose\r\n   2) Overall maximum as the LIS may end with an element before arr[n-1] \r\n      max_ref is used this purpose.\r\nThe value of LIS of full array of size n is stored in *max_ref which is our final result\r\n*/\r\nint _lis( int arr[], int n, int *max_ref)\r\n{\r\n    /* Base case */\r\n    if(n == 1)\r\n        return 1;\r\n \r\n    int res, max_ending_here = 1; // length of LIS ending with arr[n-1]\r\n \r\n    /* Recursively get all LIS ending with arr[0], arr[1] ... ar[n-2]. If \r\n       arr[i-1] is smaller than arr[n-1], and max ending with arr[n-1] needs\r\n       to be updated, then update it */\r\n    for(int i = 1; i < n; i++)\r\n    {\r\n        res = _lis(arr, i, max_ref);\r\n        if (arr[i-1] < arr[n-1] && res + 1 > max_ending_here)\r\n            max_ending_here = res + 1;\r\n    }\r\n \r\n    // Compare max_ending_here with the overall max. And update the\r\n    // overall max if needed\r\n    if (*max_ref < max_ending_here)\r\n       *max_ref = max_ending_here;\r\n \r\n    // Return length of LIS ending with arr[n-1]\r\n    return max_ending_here;\r\n}\r\n \r\n// The wrapper function for _lis()\r\nint lis(int arr[], int n)\r\n{\r\n    // The max variable holds the result\r\n    int max = 1;\r\n \r\n    // The function _lis() stores its result in max\r\n    _lis( arr, n, &max );\r\n \r\n    // returns max\r\n    return max;\r\n}\r\n \r\n/* Driver program to test above function */\r\nint main()\r\n{\r\n    int arr[] = { 10, 22, 9, 33, 21, 50, 41, 60 };\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n    printf("Length of LIS is %d\\n",  lis( arr, n ));\r\n    getchar();\r\n    return 0;\r\n}\r\n\r\nWe can see that there are many subproblems which are solved again and again. So this problem has Overlapping Substructure property and recomputation of same subproblems can be avoided by either using Memoization or Tabulation. Following is a tabluated implementation for the LIS problem.\r\n\r\n/* Dynamic Programming implementation of LIS problem */\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n \r\n/* lis() returns the length of the longest increasing subsequence in \r\n    arr[] of size n */\r\nint lis( int arr[], int n )\r\n{\r\n   int *lis, i, j, max = 0;\r\n   lis = (int*) malloc ( sizeof( int ) * n );\r\n \r\n   /* Initialize LIS values for all indexes */\r\n   for ( i = 0; i < n; i++ )\r\n      lis[i] = 1;\r\n    \r\n   /* Compute optimized LIS values in bottom up manner */\r\n   for ( i = 1; i < n; i++ )\r\n      for ( j = 0; j < i; j++ )\r\n         if ( arr[i] > arr[j] && lis[i] < lis[j] + 1)\r\n            lis[i] = lis[j] + 1;\r\n    \r\n   /* Pick maximum of all LIS values */\r\n   for ( i = 0; i < n; i++ )\r\n      if ( max < lis[i] )\r\n         max = lis[i];\r\n \r\n   /* Free memory to avoid memory leak */\r\n   free( lis );\r\n \r\n   return max;\r\n}\r\n \r\n/* Driver program to test above function */\r\nint main()\r\n{\r\n  int arr[] = { 10, 22, 9, 33, 21, 50, 41, 60 };\r\n  int n = sizeof(arr)/sizeof(arr[0]);\r\n  printf("Length of LIS is %d\\n", lis( arr, n ) );\r\n \r\n  getchar();\r\n  return 0;\r\n}\r\n', 'We have discussed Overlapping Subproblems and Optimal Substructure properties in Set 1 and Set 2 respectively.\r\n\r\nLet us discuss Longest Increasing Subsequence (LIS) problem as an example problem that can be solved using Dynamic Programming.\r\nThe longest Increasing Subsequence (LIS) problem is to find the length of the longest subsequence of a given sequence such that all elements of the subsequence are sorted in increasing order. For example, length of LIS for { 10, 22, 9, 33, 21, 50, 41, 60, 80 } is 6 and LIS is {10, 22, 33, 50, 60, 80}.\r\n\r\nOptimal Substructure:\r\nLet arr[0..n-1] be the input array and L(i) be the length of the LIS till index i such that arr[i] is part of LIS and arr[i] is the last element in LIS, then L(i) can be recursively written as.\r\nL(i) = { 1 + Max ( L(j) ) } where j < i and arr[j] < arr[i] and if there is no such j then L(i) = 1\r\nTo get LIS of a given array, we need to return max(L(i)) where 0 < i < n\r\nSo the LIS problem has optimal substructure property as the main problem can be solved using solutions to subproblems.\r\n\r\nOverlapping Subproblems:\r\nFollowing is simple recursive implementation of the LIS problem. The implementation simply follows the recursive structure mentioned above. The value of lis ending with every element is returned using max_ending_here. The overall lis is returned using pointer to a variable max.', 'Note that the time complexity of the above Dynamic Programmig (DP) solution is O(n^2) and there is a O(nLogn) solution for the LIS problem (see this). We have not discussed the nLogn solution here as the purpose of this post is to explain Dynamic Programmig with a simple example.\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Dynamic Programming', 'DP', 10);
INSERT INTO `algorithms` (`algo_id`, `author`, `date`, `title`, `short_note`, `code`, `description`, `analysis`, `category`, `tags`, `View`) VALUES
(17, 'Tarango Khan', '2015-07-22', 'Dynamic Programming | Set 4 (Longest Common Subsequence)', 'We have discussed Overlapping Subproblems and Optimal Substructure properties in Set 1 and Set 2 respectively. ', '/* A Naive recursive implementation of LCS problem */\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n \r\nint max(int a, int b);\r\n \r\n/* Returns length of LCS for X[0..m-1], Y[0..n-1] */\r\nint lcs( char *X, char *Y, int m, int n )\r\n{\r\n   if (m == 0 || n == 0)\r\n     return 0;\r\n   if (X[m-1] == Y[n-1])\r\n     return 1 + lcs(X, Y, m-1, n-1);\r\n   else\r\n     return max(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n));\r\n}\r\n \r\n/* Utility function to get max of 2 integers */\r\nint max(int a, int b)\r\n{\r\n    return (a > b)? a : b;\r\n}\r\n \r\n/* Driver program to test above function */\r\nint main()\r\n{\r\n  char X[] = "AGGTAB";\r\n  char Y[] = "GXTXAYB";\r\n \r\n  int m = strlen(X);\r\n  int n = strlen(Y);\r\n \r\n  printf("Length of LCS is %d\\n", lcs( X, Y, m, n ) );\r\n \r\n  getchar();\r\n  return 0;\r\n}\r\n\r\nTime complexity of the above naive recursive approach is O(2^n) in worst case and worst case happens when all characters of X and Y mismatch i.e., length of LCS is 0.\r\nConsidering the above implementation, following is a partial recursion tree for input strings “AXYT” and “AYZX”\r\n\r\n                         lcs("AXYT", "AYZX")\r\n                       /                 \\\r\n         lcs("AXY", "AYZX")            lcs("AXYT", "AYZ")\r\n         /            \\                  /               \\\r\nlcs("AX", "AYZX") lcs("AXY", "AYZ")   lcs("AXY", "AYZ") lcs("AXYT", "AY")\r\nIn the above partial recursion tree, lcs(“AXY”, “AYZ”) is being solved twice. If we draw the complete recursion tree, then we can see that there are many subproblems which are solved again and again. So this problem has Overlapping Substructure property and recomputation of same subproblems can be avoided by either using Memoization or Tabulation. Following is a tabulated implementation for the LCS problem.\r\n\r\n/* Dynamic Programming implementation of LCS problem */\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n  \r\nint max(int a, int b);\r\n  \r\n/* Returns length of LCS for X[0..m-1], Y[0..n-1] */\r\nint lcs( char *X, char *Y, int m, int n )\r\n{\r\n   int L[m+1][n+1];\r\n   int i, j;\r\n  \r\n   /* Following steps build L[m+1][n+1] in bottom up fashion. Note \r\n      that L[i][j] contains length of LCS of X[0..i-1] and Y[0..j-1] */\r\n   for (i=0; i<=m; i++)\r\n   {\r\n     for (j=0; j<=n; j++)\r\n     {\r\n       if (i == 0 || j == 0)\r\n         L[i][j] = 0;\r\n  \r\n       else if (X[i-1] == Y[j-1])\r\n         L[i][j] = L[i-1][j-1] + 1;\r\n  \r\n       else\r\n         L[i][j] = max(L[i-1][j], L[i][j-1]);\r\n     }\r\n   }\r\n    \r\n   /* L[m][n] contains length of LCS for X[0..n-1] and Y[0..m-1] */\r\n   return L[m][n];\r\n}\r\n  \r\n/* Utility function to get max of 2 integers */\r\nint max(int a, int b)\r\n{\r\n    return (a > b)? a : b;\r\n}\r\n  \r\n/* Driver program to test above function */\r\nint main()\r\n{\r\n  char X[] = "AGGTAB";\r\n  char Y[] = "GXTXAYB";\r\n  \r\n  int m = strlen(X);\r\n  int n = strlen(Y);\r\n  \r\n  printf("Length of LCS is %d\\n", lcs( X, Y, m, n ) );\r\n  \r\n  getchar();\r\n  return 0;\r\n}\r\n', 'We have discussed Overlapping Subproblems and Optimal Substructure properties in Set 1 and Set 2 respectively. We also discussed one example problem in Set 3. Let us discuss Longest Common Subsequence (LCS) problem as one more example problem that can be solved using Dynamic Programming.\r\n\r\nLCS Problem Statement: Given two sequences, find the length of longest subsequence present in both of them. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. For example, “abc”, “abg”, “bdf”, “aeg”, ‘”acefg”, .. etc are subsequences of “abcdefg”. So a string of length n has 2^n different possible subsequences.\r\n\r\nIt is a classic computer science problem, the basis of diff (a file comparison program that outputs the differences between two files), and has applications in bioinformatics.\r\n\r\nExamples:\r\nLCS for input Sequences “ABCDGH” and “AEDFHR” is “ADH” of length 3.\r\nLCS for input Sequences “AGGTAB” and “GXTXAYB” is “GTAB” of length 4.\r\n\r\nThe naive solution for this problem is to generate all subsequences of both given sequences and find the longest matching subsequence. This solution is exponential in term of time complexity. Let us see how this problem possesses both important properties of a Dynamic Programming (DP) Problem.\r\n\r\n1) Optimal Substructure: \r\nLet the input sequences be X[0..m-1] and Y[0..n-1] of lengths m and n respectively. And let L(X[0..m-1], Y[0..n-1]) be the length of LCS of the two sequences X and Y. Following is the recursive definition of L(X[0..m-1], Y[0..n-1]).\r\n\r\nIf last characters of both sequences match (or X[m-1] == Y[n-1]) then\r\nL(X[0..m-1], Y[0..n-1]) = 1 + L(X[0..m-2], Y[0..n-2])\r\n\r\nIf last characters of both sequences do not match (or X[m-1] != Y[n-1]) then\r\nL(X[0..m-1], Y[0..n-1]) = MAX ( L(X[0..m-2], Y[0..n-1]), L(X[0..m-1], Y[0..n-2])\r\n\r\nExamples:\r\n1) Consider the input strings “AGGTAB” and “GXTXAYB”. Last characters match for the strings. So length of LCS can be written as:\r\nL(“AGGTAB”, “GXTXAYB”) = 1 + L(“AGGTA”, “GXTXAY”)\r\n\r\n2) Consider the input strings “ABCDGH” and “AEDFHR. Last characters do not match for the strings. So length of LCS can be written as:\r\nL(“ABCDGH”, “AEDFHR”) = MAX ( L(“ABCDG”, “AEDFHR”), L(“ABCDGH”, “AEDFH”) )\r\n\r\nSo the LCS problem has optimal substructure property as the main problem can be solved using solutions to subproblems.\r\n\r\n2) Overlapping Subproblems:\r\nFollowing is simple recursive implementation of the LCS problem. The implementation simply follows the recursive structure mentioned above.', 'Time Complexity of the above implementation is O(mn) which is much better than the worst case time complexity of Naive Recursive implementation.\r\n\r\nThe above algorithm/code returns only length of LCS. Please see the following post for printing the LCS.\r\nPrinting Longest Common Subsequence\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\r\n\r\nReferences: \r\nhttp://www.youtube.com/watch?v=V5hZoJ6uK-s\r\nhttp://www.algorithmist.com/index.php/Longest_Common_Subsequence\r\nhttp://www.ics.uci.edu/~eppstein/161/960229.html\r\nhttp://en.wikipedia.org/wiki/Longest_common_subsequence_problem', 'Dynamic Programming', 'DP', 10),
(18, 'Tarango Khan', '2015-07-22', 'Dynamic Programming | Set 5 (Edit Distance)', 'Continuing further on dynamic programming series, edit distance is an interesting algorithm.', '// Dynamic Programming implementation of edit distance\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n \r\n// Change these strings to test the program\r\n#define STRING_X "SUNDAY"\r\n#define STRING_Y "SATURDAY"\r\n \r\n#define SENTINEL (-1)\r\n#define EDIT_COST (1)\r\n \r\ninline\r\nint min(int a, int b) {\r\n   return a < b ? a : b;\r\n}\r\n \r\n// Returns Minimum among a, b, c\r\nint Minimum(int a, int b, int c)\r\n{\r\n    return min(min(a, b), c);\r\n}\r\n \r\n// Strings of size m and n are passed.\r\n// Construct the Table for X[0...m, m+1], Y[0...n, n+1]\r\nint EditDistanceDP(char X[], char Y[])\r\n{\r\n    // Cost of alignment\r\n    int cost = 0;\r\n    int leftCell, topCell, cornerCell;\r\n \r\n    int m = strlen(X)+1;\r\n    int n = strlen(Y)+1;\r\n \r\n    // T[m][n]\r\n    int *T = (int *)malloc(m * n * sizeof(int));\r\n \r\n    // Initialize table\r\n    for(int i = 0; i < m; i++)\r\n        for(int j = 0; j < n; j++)\r\n            *(T + i * n + j) = SENTINEL;\r\n \r\n    // Set up base cases\r\n    // T[i][0] = i\r\n    for(int i = 0; i < m; i++)\r\n        *(T + i * n) = i;\r\n \r\n    // T[0][j] = j\r\n    for(int j = 0; j < n; j++)\r\n        *(T + j) = j;\r\n \r\n    // Build the T in top-down fashion\r\n    for(int i = 1; i < m; i++)\r\n    {\r\n        for(int j = 1; j < n; j++)\r\n        {\r\n            // T[i][j-1]\r\n            leftCell = *(T + i*n + j-1);\r\n            leftCell += EDIT_COST; // deletion\r\n \r\n            // T[i-1][j]\r\n            topCell = *(T + (i-1)*n + j);\r\n            topCell += EDIT_COST; // insertion\r\n \r\n            // Top-left (corner) cell\r\n            // T[i-1][j-1]\r\n            cornerCell = *(T + (i-1)*n + (j-1) );\r\n \r\n            // edit[(i-1), (j-1)] = 0 if X[i] == Y[j], 1 otherwise\r\n            cornerCell += (X[i-1] != Y[j-1]); // may be replace\r\n \r\n            // Minimum cost of current cell\r\n            // Fill in the next cell T[i][j]\r\n            *(T + (i)*n + (j)) = Minimum(leftCell, topCell, cornerCell);\r\n        }\r\n    }\r\n \r\n    // Cost is in the cell T[m][n]\r\n    cost = *(T + m*n - 1);\r\n    free(T);\r\n    return cost;\r\n}\r\n \r\n// Recursive implementation\r\nint EditDistanceRecursion( char *X, char *Y, int m, int n )\r\n{\r\n    // Base cases\r\n    if( m == 0 && n == 0 )\r\n        return 0;\r\n \r\n    if( m == 0 )\r\n        return n;\r\n \r\n    if( n == 0 )\r\n        return m;\r\n \r\n    // Recurse\r\n    int left = EditDistanceRecursion(X, Y, m-1, n) + 1;\r\n    int right = EditDistanceRecursion(X, Y, m, n-1) + 1;\r\n    int corner = EditDistanceRecursion(X, Y, m-1, n-1) + (X[m-1] != Y[n-1]);\r\n \r\n    return Minimum(left, right, corner);\r\n}\r\n \r\nint main()\r\n{\r\n    char X[] = STRING_X; // vertical\r\n    char Y[] = STRING_Y; // horizontal\r\n \r\n    printf("Minimum edits required to convert %s into %s is %d\\n",\r\n           X, Y, EditDistanceDP(X, Y) );\r\n    printf("Minimum edits required to convert %s into %s is %d by recursion\\n",\r\n           X, Y, EditDistanceRecursion(X, Y, strlen(X), strlen(Y)));\r\n \r\n    return 0;\r\n}', 'Problem: Given two strings of size m, n and set of operations replace (R), insert (I) and delete (D) all at equal cost. Find minimum number of edits (operations) required to convert one string into another.\r\n\r\nIdentifying Recursive Methods:\r\n\r\nWhat will be sub-problem in this case? Consider finding edit distance of part of the strings, say small prefix. Let us denote them as [1…i] and [1…j] for some 1< i < m and 1 < j < n. Clearly it is solving smaller instance of final problem, denote it as E(i, j). Our goal is finding E(m, n) and minimizing the cost.\r\n\r\nIn the prefix, we can right align the strings in three ways (i, -), (-, j) and (i, j). The hyphen symbol (-) representing no character. An example can make it more clear.\r\n\r\nGiven strings SUNDAY and SATURDAY. We want to convert SUNDAY into SATURDAY with minimum edits. Let us pick i = 2 and j = 4 i.e. prefix strings are SUN and SATU respectively (assume the strings indices start at 1). The right most characters can be aligned in three different ways.\r\n\r\nCase 1: Align characters U and U. They are equal, no edit is required. We still left with the problem of i = 1 and j = 3, E(i-1, j-1).\r\n\r\nCase 2: Align right character from first string and no character from second string. We need a deletion (D) here. We still left with problem of i = 1 and j = 4, E(i-1, j).\r\n\r\nCase 3: Align right character from second string and no character from first string. We need an insertion (I) here. We still left with problem of i = 2 and j = 3, E(i, j-1).\r\n\r\nCombining all the subproblems minimum cost of aligning prefix strings ending at i and j given by\r\n\r\nE(i, j) = min( [E(i-1, j) + D], [E(i, j-1) + I],  [E(i-1, j-1) + R if i,j characters are not same] )\r\n\r\nWe still not yet done. What will be base case(s)?\r\n\r\nWhen both of the strings are of size 0, the cost is 0. When only one of the string is zero, we need edit operations as that of non-zero length string. Mathematically,\r\n\r\nE(0, 0) = 0, E(i, 0) = i, E(0, j) = j\r\n\r\nNow it is easy to complete recursive method. Go through the code for recursive algorithm (edit_distance_recursive).\r\n\r\nDynamic Programming Method:\r\n\r\nWe can calculate the complexity of recursive expression fairly easily.\r\n\r\nT(m, n) = T(m-1, n-1) + T(m, n-1) + T(m-1, n) + C\r\n\r\nThe complexity of T(m, n) can be calculated by successive substitution method or solving homogeneous equation of two variables. It will result in an exponential complexity algorithm. It is evident from the recursion tree that it will be solving subproblems again and again. Few strings result in many overlapping subproblems (try the below program with strings exponential and polynomial and note the delay in recursive method).\r\n\r\nWe can tabulate the repeating subproblems and look them up when required next time (bottom up). A two dimensional array formed by the strings can keep track of the minimum cost till the current character comparison. The visualization code will help in understanding the construction of matrix.\r\n\r\nThe time complexity of dynamic programming method is O(mn) as we need to construct the table fully. The space complexity is also O(mn). If we need only the cost of edit, we just need O(min(m, n)) space as it is required only to keep track of the current row and previous row.\r\n\r\nUsually the costs D, I and R are not same. In such case the problem can be represented as an acyclic directed graph (DAG) with weights on each edge, and finding shortest path gives edit distance.\r\n\r\nApplications:\r\n\r\nThere are many practical applications of edit distance algorithm, refer Lucene API for sample. Another example, display all the words in a dictionary that are near proximity to a given word\\incorrectly spelled word.', ' Venki. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Dynamic Programming', 'DP', 10),
(19, 'Tarango Khan', '2015-07-22', 'Dynamic Programming | Set 6 (Min Cost Path)', 'Given a cost matrix cost[][] and a position (m, n) in cost[][], write a function that returns cost of minimum cost path to reach ', '/* A Naive recursive implementation of MCP(Minimum Cost Path) problem */\r\n#include<stdio.h>\r\n#include<limits.h>\r\n#define R 3\r\n#define C 3\r\n \r\nint min(int x, int y, int z);\r\n \r\n/* Returns cost of minimum cost path from (0,0) to (m, n) in mat[R][C]*/\r\nint minCost(int cost[R][C], int m, int n)\r\n{\r\n   if (n < 0 || m < 0)\r\n      return INT_MAX;\r\n   else if (m == 0 && n == 0)\r\n      return cost[m][n];\r\n   else\r\n      return cost[m][n] + min( minCost(cost, m-1, n-1),\r\n                               minCost(cost, m-1, n), \r\n                               minCost(cost, m, n-1) );\r\n}\r\n \r\n/* A utility function that returns minimum of 3 integers */\r\nint min(int x, int y, int z)\r\n{\r\n   if (x < y)\r\n      return (x < z)? x : z;\r\n   else\r\n      return (y < z)? y : z;\r\n}\r\n \r\n/* Driver program to test above functions */\r\nint main()\r\n{\r\n   int cost[R][C] = { {1, 2, 3},\r\n                      {4, 8, 2},\r\n                      {1, 5, 3} };\r\n   printf(" %d ", minCost(cost, 2, 2));\r\n   return 0;\r\n}\r\n\r\nIt should be noted that the above function computes the same subproblems again and again. See the following recursion tree, there are many nodes which apear more than once. Time complexity of this naive recursive solution is exponential and it is terribly slow.\r\n\r\nmC refers to minCost()\r\n                                    mC(2, 2)\r\n                          /            |           \\\r\n                         /             |            \\             \r\n                 mC(1, 1)           mC(1, 2)             mC(2, 1)\r\n              /     |     \\       /     |     \\           /     |     \\ \r\n             /      |      \\     /      |      \\         /      |       \\\r\n       mC(0,0) mC(0,1) mC(1,0) mC(0,1) mC(0,2) mC(1,1) mC(1,0) mC(1,1) mC(2,0) \r\nSo the MCP problem has both properties (see this and this) of a dynamic programming problem. Like other typical Dynamic Programming(DP) problems, recomputations of same subproblems can be avoided by constructing a temporary array tc[][] in bottom up manner.\r\n\r\n/* Dynamic Programming implementation of MCP problem */\r\n#include<stdio.h>\r\n#include<limits.h>\r\n#define R 3\r\n#define C 3\r\n \r\nint min(int x, int y, int z);\r\n \r\nint minCost(int cost[R][C], int m, int n)\r\n{\r\n     int i, j;\r\n \r\n     // Instead of following line, we can use int tc[m+1][n+1] or \r\n     // dynamically allocate memoery to save space. The following line is\r\n     // used to keep te program simple and make it working on all compilers.\r\n     int tc[R][C];  \r\n \r\n     tc[0][0] = cost[0][0];\r\n \r\n     /* Initialize first column of total cost(tc) array */\r\n     for (i = 1; i <= m; i++)\r\n        tc[i][0] = tc[i-1][0] + cost[i][0];\r\n \r\n     /* Initialize first row of tc array */\r\n     for (j = 1; j <= n; j++)\r\n        tc[0][j] = tc[0][j-1] + cost[0][j];\r\n \r\n     /* Construct rest of the tc array */\r\n     for (i = 1; i <= m; i++)\r\n        for (j = 1; j <= n; j++)\r\n            tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j];\r\n \r\n     return tc[m][n];\r\n}\r\n \r\n/* A utility function that returns minimum of 3 integers */\r\nint min(int x, int y, int z)\r\n{\r\n   if (x < y)\r\n      return (x < z)? x : z;\r\n   else\r\n      return (y < z)? y : z;\r\n}\r\n \r\n/* Driver program to test above functions */\r\nint main()\r\n{\r\n   int cost[R][C] = { {1, 2, 3},\r\n                      {4, 8, 2},\r\n                      {1, 5, 3} };\r\n   printf(" %d ", minCost(cost, 2, 2));\r\n   return 0;\r\n}', 'Given a cost matrix cost[][] and a position (m, n) in cost[][], write a function that returns cost of minimum cost path to reach (m, n) from (0, 0). Each cell of the matrix represents a cost to traverse through that cell. Total cost of a path to reach (m, n) is sum of all the costs on that path (including both source and destination). You can only traverse down, right and diagonally lower cells from a given cell, i.e., from a given cell (i, j), cells (i+1, j), (i, j+1) and (i+1, j+1) can be traversed. You may assume that all costs are positive integers.\r\n\r\nFor example, in the following figure, what is the minimum cost path to (2, 2)?\r\n1) Optimal Substructure\r\nThe path to reach (m, n) must be through one of the 3 cells: (m-1, n-1) or (m-1, n) or (m, n-1). So minimum cost to reach (m, n) can be written as “minimum of the 3 cells plus cost[m][n]”.\r\n\r\nminCost(m, n) = min (minCost(m-1, n-1), minCost(m-1, n), minCost(m, n-1)) + cost[m][n]\r\n\r\n2) Overlapping Subproblems\r\nFollowing is simple recursive implementation of the MCP (Minimum Cost Path) problem. The implementation simply follows the recursive structure mentioned above.', 'Time Complexity of the DP implementation is O(mn) which is much better than Naive Recursive implementation.\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above', 'Dynamic Programming', 'DP', 10),
(20, 'Tarango Khan', '2015-07-22', 'Dynamic Programming | Set 7 (Coin Change)', 'Given a value N, if we want to make change for N cents, and we have infinite supply of each of S = { S1, S2, .. , Sm} valued coins', '#include<stdio.h>\r\n \r\n// Returns the count of ways we can sum  S[0...m-1] coins to get sum n\r\nint count( int S[], int m, int n )\r\n{\r\n    // If n is 0 then there is 1 solution (do not include any coin)\r\n    if (n == 0)\r\n        return 1;\r\n     \r\n    // If n is less than 0 then no solution exists\r\n    if (n < 0)\r\n        return 0;\r\n \r\n    // If there are no coins and n is greater than 0, then no solution exist\r\n    if (m <=0 && n >= 1)\r\n        return 0;\r\n \r\n    // count is sum of solutions (i) including S[m-1] (ii) excluding S[m-1]\r\n    return count( S, m - 1, n ) + count( S, m, n-S[m-1] );\r\n}\r\n \r\n// Driver program to test above function\r\nint main()\r\n{\r\n    int i, j;\r\n    int arr[] = {1, 2, 3};\r\n    int m = sizeof(arr)/sizeof(arr[0]);\r\n    printf("%d ", count(arr, m, 4));\r\n    getchar();\r\n    return 0;\r\n}\r\n\r\nIt should be noted that the above function computes the same subproblems again and again. See the following recursion tree for S = {1, 2, 3} and n = 5.\r\nThe function C({1}, 3) is called two times. If we draw the complete tree, then we can see that there are many subproblems being called more than once.\r\n\r\nC() --> count()\r\n                              C({1,2,3}, 5)                     \r\n                           /                \\\r\n                         /                   \\              \r\n             C({1,2,3}, 2)                 C({1,2}, 5)\r\n            /     \\                        /         \\\r\n           /        \\                     /           \\\r\nC({1,2,3}, -1)  C({1,2}, 2)        C({1,2}, 3)    C({1}, 5)\r\n               /     \\            /    \\            /     \\\r\n             /        \\          /      \\          /       \\\r\n    C({1,2},0)  C({1},2)   C({1,2},1) C({1},3)    C({1}, 4)  C({}, 5)\r\n                   / \\      / \\       / \\        /     \\    \r\n                  /   \\    /   \\     /   \\      /       \\ \r\n                .      .  .     .   .     .   C({1}, 3) C({}, 4)\r\n                                               /  \\\r\n                                              /    \\  \r\n                                             .      .\r\nSince same suproblems are called again, this problem has Overlapping Subprolems property. So the Coin Change problem has both properties (see this and this) of a dynamic programming problem. Like other typical Dynamic Programming(DP) problems, recomputations of same subproblems can be avoided by constructing a temporary array table[][] in bottom up manner.\r\n\r\nDynamic Programming Solution\r\n\r\n#include<stdio.h>\r\n \r\nint count( int S[], int m, int n )\r\n{\r\n    int i, j, x, y;\r\n \r\n    // We need n+1 rows as the table is consturcted in bottom up manner using \r\n    // the base case 0 value case (n = 0)\r\n    int table[n+1][m];\r\n    \r\n    // Fill the enteries for 0 value case (n = 0)\r\n    for (i=0; i<m; i++)\r\n        table[0][i] = 1;\r\n \r\n    // Fill rest of the table enteries in bottom up manner  \r\n    for (i = 1; i < n+1; i++)\r\n    {\r\n        for (j = 0; j < m; j++)\r\n        {\r\n            // Count of solutions including S[j]\r\n            x = (i-S[j] >= 0)? table[i - S[j]][j]: 0;\r\n \r\n            // Count of solutions excluding S[j]\r\n            y = (j >= 1)? table[i][j-1]: 0;\r\n \r\n            // total count\r\n            table[i][j] = x + y;\r\n        }\r\n    }\r\n    return table[n][m-1];\r\n}\r\n \r\n// Driver program to test above function\r\nint main()\r\n{\r\n    int arr[] = {1, 2, 3};\r\n    int m = sizeof(arr)/sizeof(arr[0]);\r\n    int n = 4;\r\n    printf(" %d ", count(arr, m, n));\r\n    return 0;\r\n}\r\n\r\nTime Complexity: O(mn)\r\n\r\nFollowing is a simplified version of method 2. The auxiliary space required here is O(n) only.\r\n\r\nint count( int S[], int m, int n )\r\n{\r\n    // table[i] will be storing the number of solutions for\r\n    // value i. We need n+1 rows as the table is consturcted\r\n    // in bottom up manner using the base case (n = 0)\r\n    int table[n+1];\r\n \r\n    // Initialize all table values as 0\r\n    memset(table, 0, sizeof(table));\r\n \r\n    // Base case (If given value is 0)\r\n    table[0] = 1;\r\n \r\n    // Pick all coins one by one and update the table[] values\r\n    // after the index greater than or equal to the value of the\r\n    // picked coin\r\n    for(int i=0; i<m; i++)\r\n        for(int j=S[i]; j<=n; j++)\r\n            table[j] += table[j-S[i]];\r\n \r\n    return table[n];\r\n}', 'Given a value N, if we want to make change for N cents, and we have infinite supply of each of S = { S1, S2, .. , Sm} valued coins, how many ways can we make the change? The order of coins doesn’t matter.\r\n\r\nFor example, for N = 4 and S = {1,2,3}, there are four solutions: {1,1,1,1},{1,1,2},{2,2},{1,3}. So output should be 4. For N = 10 and S = {2, 5, 3, 6}, there are five solutions: {2,2,2,2,2}, {2,2,3,3}, {2,2,6}, {2,3,5} and {5,5}. So the output should be 5.\r\n\r\n1) Optimal Substructure\r\nTo count total number solutions, we can divide all set solutions in two sets.\r\n1) Solutions that do not contain mth coin (or Sm).\r\n2) Solutions that contain at least one Sm.\r\nLet count(S[], m, n) be the function to count the number of solutions, then it can be written as sum of count(S[], m-1, n) and count(S[], m, n-Sm).\r\n\r\nTherefore, the problem has optimal substructure property as the problem can be solved using solutions to subproblems.\r\n\r\n2) Overlapping Subproblems\r\nFollowing is a simple recursive implementation of the Coin Change problem. The implementation simply follows the recursive structure mentioned above.', 'Thanks to Rohan Laishram for suggesting this space optimized version.\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\r\n\r\nReferences:\r\nhttp://www.algorithmist.com/index.php/Coin_Change', 'Dynamic Programming', 'DP', 10),
(21, 'Tarango Khan', '2015-07-22', 'Find the element that appears once', 'Given an array where every element occurs three times, except one element which occurs only once. ', '#include <stdio.h>\r\n \r\nint getSingle(int arr[], int n)\r\n{\r\n    int ones = 0, twos = 0 ;\r\n \r\n    int common_bit_mask;\r\n \r\n    // Let us take the example of {3, 3, 2, 3} to understand this\r\n    for( int i=0; i< n; i++ )\r\n    {\r\n        /* The expression "one & arr[i]" gives the bits that are\r\n           there in both ''ones'' and new element from arr[].  We\r\n           add these bits to ''twos'' using bitwise OR\r\n \r\n           Value of ''twos'' will be set as 0, 3, 3 and 1 after 1st,\r\n           2nd, 3rd and 4th iterations respectively */\r\n        twos  = twos | (ones & arr[i]);\r\n \r\n \r\n        /* XOR the new bits with previous ''ones'' to get all bits\r\n           appearing odd number of times\r\n \r\n           Value of ''ones'' will be set as 3, 0, 2 and 3 after 1st,\r\n           2nd, 3rd and 4th iterations respectively */\r\n        ones  = ones ^ arr[i];\r\n \r\n \r\n        /* The common bits are those bits which appear third time\r\n           So these bits should not be there in both ''ones'' and ''twos''.\r\n           common_bit_mask contains all these bits as 0, so that the bits can \r\n           be removed from ''ones'' and ''twos''   \r\n \r\n           Value of ''common_bit_mask'' will be set as 00, 00, 01 and 10\r\n           after 1st, 2nd, 3rd and 4th iterations respectively */\r\n        common_bit_mask = ~(ones & twos);\r\n \r\n \r\n        /* Remove common bits (the bits that appear third time) from ''ones''\r\n             \r\n           Value of ''ones'' will be set as 3, 0, 0 and 2 after 1st,\r\n           2nd, 3rd and 4th iterations respectively */\r\n        ones &= common_bit_mask;\r\n \r\n \r\n        /* Remove common bits (the bits that appear third time) from ''twos''\r\n \r\n           Value of ''twos'' will be set as 0, 3, 1 and 0 after 1st,\r\n           2nd, 3rd and 4th itearations respectively */\r\n        twos &= common_bit_mask;\r\n \r\n        // uncomment this code to see intermediate values\r\n        //printf (" %d %d \\n", ones, twos);\r\n    }\r\n \r\n    return ones;\r\n}\r\n \r\nint main()\r\n{\r\n    int arr[] = {3, 3, 2, 3};\r\n    int n = sizeof(arr) / sizeof(arr[0]);\r\n    printf("The element with single occurrence is %d ",\r\n            getSingle(arr, n));\r\n    return 0;\r\n}', 'Given an array where every element occurs three times, except one element which occurs only once. Find the element that occurs once. Expected time complexity is O(n) and O(1) extra space.\r\nExamples:\r\n\r\nInput: arr[] = {12, 1, 12, 3, 12, 1, 1, 2, 3, 3}\r\nOutput: 2\r\nWe can use sorting to do it in O(nLogn) time. We can also use hashing, but the worst case time complexity of hashing may be more than O(n) and hashing requires extra space.\r\n\r\nThe idea is to use bitwise operators for a solution that is O(n) time and uses O(1) extra space. The solution is not easy like other XOR based solutions, because all elements appear odd number of times here. The idea is taken from here.\r\n\r\nRun a loop for all elements in array. At the end of every iteration, maintain following two values.\r\n\r\nones: The bits that have appeared 1st time or 4th time or 7th time .. etc.\r\n\r\ntwos: The bits that have appeared 2nd time or 5th time or 8th time .. etc.\r\n\r\nFinally, we return the value of ‘ones’\r\n\r\nHow to maintain the values of ‘ones’ and ‘twos’?\r\n‘ones’ and ‘twos’ are initialized as 0. For every new element in array, find out the common set bits in the new element and previous value of ‘ones’. These common set bits are actually the bits that should be added to ‘twos’. So do bitwise OR of the common set bits with ‘twos’. ‘twos’ also gets some extra bits that appear third time. These extra bits are removed later.\r\nUpdate ‘ones’ by doing XOR of new element with previous value of ‘ones’. There may be some bits which appear 3rd time. These extra bits are also removed later.\r\n\r\nBoth ‘ones’ and ‘twos’ contain those extra bits which appear 3rd time. Remove these extra bits by finding out common set bits in ‘ones’ and ‘twos’.', 'Time Complexity: O(n)\r\nAuxiliary Space: O(1)\r\n\r\nFollowing is another O(n) time complexity and O(1) extra space method suggested by aj. We can sum the bits in same positions for all the numbers and take modulo with 3. The bits for which sum is not multiple of 3, are the bits of number with single occurrence.\r\nLet us consider the example array {5, 5, 5, 8}. The 101, 101, 101, 1000\r\nSum of first bits%3 = (1 + 1 + 1 + 0)%3 = 0;\r\nSum of second bits%3 = (0 + 0 + 0 + 0)%0 = 0;\r\nSum of third bits%3 = (1 + 1 + 1 + 0)%3 = 0;\r\nSum of fourth bits%3 = (1)%3 = 1;\r\nHence number which appears once is 1000\r\n\r\n#include <stdio.h>\r\n#define INT_SIZE 32\r\n \r\nint getSingle(int arr[], int n)\r\n{\r\n    // Initialize result\r\n    int result = 0;\r\n \r\n    int x, sum;\r\n \r\n    // Iterate through every bit\r\n    for (int i = 0; i < INT_SIZE; i++)\r\n    {\r\n      // Find sum of set bits at ith position in all\r\n      // array elements\r\n      sum = 0;\r\n      x = (1 << i);\r\n      for (int j=0; j< n; j++ )\r\n      {\r\n          if (arr[j] & x)\r\n            sum++;\r\n      }\r\n \r\n      // The bits with sum not multiple of 3, are the\r\n      // bits of element with single occurrence.\r\n      if (sum % 3)\r\n        result |= x;\r\n    }\r\n \r\n    return result;\r\n}\r\n \r\n// Driver program to test above function\r\nint main()\r\n{\r\n    int arr[] = {12, 1, 12, 3, 12, 1, 1, 2, 3, 2, 2, 3, 7};\r\n    int n = sizeof(arr) / sizeof(arr[0]);\r\n    printf("The element with single occurrence is %d ",\r\n            getSingle(arr, n));\r\n    return 0;\r\n}', 'Bit Magic', 'Bit', 10),
(22, 'Tarango Khan', '2015-07-22', 'Detect if two integers have opposite signs', 'Given two signed integers, write a function that returns true if the signs of given integers are different', '#include<stdbool.h>\r\n#include<stdio.h>\r\n \r\nbool oppositeSigns(int x, int y)\r\n{\r\n    return ((x ^ y) < 0);\r\n}\r\n \r\nint main()\r\n{\r\n    int x = 100, y = -100;\r\n    if (oppositeSigns(x, y) == true)\r\n       printf ("Signs are opposite");\r\n    else\r\n      printf ("Signs are not opposite");\r\n    return 0;\r\n}\r\n\r\nSource: Detect if two integers have opposite signs\r\n\r\nWe can also solve this by using two comparison operators. See the following code.\r\n\r\nbool oppositeSigns(int x, int y)\r\n{\r\n    return (x < 0)? (y >= 0): (y < 0);\r\n}\r\n\r\nThe first method is more efficient. The first method uses a bitwise XOR and a comparison operator. The second method uses two comparison operators and a bitwise XOR operation is more efficient compared to a comparison operation.\r\n\r\nWe can also use following method. It doesn’t use any comparison operator. The method is suggested by Hongliang and improved by gaurav.\r\n\r\nbool oppositeSigns(int x, int y)\r\n{\r\n    return ((x ^ y) >> 31);\r\n}', 'Given two signed integers, write a function that returns true if the signs of given integers are different, otherwise false. For example, the function should return true -1 and +100, and should return false for -100 and -200. The function should not use any of the arithmetic operators.\r\n\r\nLet the given integers be x and y. The sign bit is 1 in negative numbers, and 0 in positive numbers. The XOR of x and y will have the sign bit as 1 iff they have opposite sign. In other words, XOR of x and y will be negative number number iff x and y have opposite signs. The following code use this logic.', 'The function is written only for compilers where size of an integer is 32 bit. The expression basically checks sign of (x^y) using bitwise operator ‘>>’. As mentioned above, the sign bit for negative numbers is always 1. The sign bit is the leftmost bit in binary representation. So we need to checks whether the 32th bit (or leftmost bit) of x^y is 1 or not. We do it by right shifting the value of x^y by 31, so that the sign bit becomes the least significant bit. If sign bit is 1, then the value of (x^y)>>31 will be 1, otherwise 0.\r\n\r\nPlease write comments if you find any of the above codes/algorithms incorrect, or find other ways to solve the same problem.', 'Bit Magic', 'Bit', 10),
(23, 'Tarango Khan', '2015-07-22', 'Count total set bits in all numbers from 1 to n', 'Given a positive integer n, count the total number of set bits in binary representation of all numbers from 1 to n.', 'Method 2 (Tricky) \r\nIf the input number is of the form 2^b -1 e.g., 1,3,7,15.. etc, the number of set bits is b * 2^(b-1). This is because for all the numbers 0 to (2^b)-1, if you complement and flip the list you end up with the same list (half the bits are on, half off).\r\n\r\nIf the number does not have all set bits, then some position m is the position of leftmost set bit. The number of set bits in that position is n – (1 << m) + 1. The remaining set bits are in two parts:\r\n\r\n1) The bits in the (m-1) positions down to the point where the leftmost bit becomes 0, and\r\n2) The 2^(m-1) numbers below that point, which is the closed form above.\r\n\r\nAn easy way to look at it is to consider the number 6:\r\n\r\n0|0 0\r\n0|0 1\r\n0|1 0\r\n0|1 1\r\n-|–\r\n1|0 0\r\n1|0 1\r\n1|1 0\r\nThe leftmost set bit is in position 2 (positions are considered starting from 0). If we mask that off what remains is 2 (the “1 0? in the right part of the last row.) So the number of bits in the 2nd position (the lower left box) is 3 (that is, 2 + 1). The set bits from 0-3 (the upper right box above) is 2*2^(2-1) = 4. The box in the lower right is the remaining bits we haven’t yet counted, and is the number of set bits for all the numbers up to 2 (the value of the last entry in the lower right box) which can be figured recursively.\r\n\r\n// A O(Logn) complexity program to count set bits in all numbers from 1 to n\r\n#include <stdio.h>\r\n \r\n/* Returns position of leftmost set bit. The rightmost\r\n   position is considered as 0 */\r\nunsigned int getLeftmostBit (int n)\r\n{\r\n   int m = 0;\r\n   while (n  > 1)\r\n   {\r\n      n = n >> 1;\r\n      m++;\r\n   }\r\n   return m;\r\n}\r\n \r\n/* Given the position of previous leftmost set bit in n (or an upper\r\n   bound on leftmost position) returns the new position of leftmost\r\n   set bit in n  */\r\nunsigned int getNextLeftmostBit (int n, int m)\r\n{\r\n   unsigned int temp = 1 << m;\r\n   while (n  < temp)\r\n   {\r\n      temp = temp >> 1;\r\n      m--;\r\n   }\r\n   return m;\r\n}\r\n \r\n// The main recursive function used by countSetBits()\r\nunsigned int _countSetBits(unsigned int n, int m);\r\n \r\n// Returns count of set bits present in all numbers from 1 to n\r\nunsigned int countSetBits(unsigned int n)\r\n{\r\n   // Get the position of leftmost set bit in n. This will be\r\n   // used as an upper bound for next set bit function\r\n   int m = getLeftmostBit (n);\r\n \r\n   // Use the position\r\n   return _countSetBits (n, m);\r\n}\r\n \r\nunsigned int _countSetBits(unsigned int n, int m)\r\n{\r\n    // Base Case: if n is 0, then set bit count is 0\r\n    if (n == 0)\r\n       return 0;\r\n \r\n    /* get position of next leftmost set bit */\r\n    m = getNextLeftmostBit(n, m);\r\n \r\n    // If n is of the form 2^x-1, i.e., if n is like 1, 3, 7, 15, 31,.. etc, \r\n    // then we are done. \r\n    // Since positions are considered starting from 0, 1 is added to m\r\n    if (n == ((unsigned int)1<<(m+1))-1)\r\n        return (unsigned int)(m+1)*(1<<m);\r\n \r\n    // update n for next recursive call\r\n    n = n - (1<<m);\r\n    return (n+1) + countSetBits(n) + m*(1<<(m-1));\r\n}\r\n \r\n// Driver program to test above functions\r\nint main()\r\n{\r\n   int n = 17;\r\n   printf ("Total set bit count is %d", countSetBits(n));\r\n   return 0;\r\n}', 'Given a positive integer n, count the total number of set bits in binary representation of all numbers from 1 to n.\r\n\r\nExamples:\r\n\r\nInput: n = 3\r\nOutput:  4\r\n\r\nInput: n = 6\r\nOutput: 9\r\n\r\nInput: n = 7\r\nOutput: 12\r\n\r\nInput: n = 8\r\nOutput: 13\r\nSource: Amazon Interview Question\r\n\r\nMethod 1 (Simple)\r\nA simple solution is to run a loop from 1 to n and sum the count of set bits in all numbers from 1 to n.\r\n\r\n// A simple program to count set bits in all numbers from 1 to n.\r\n#include <stdio.h>\r\n \r\n// A utility function to count set bits in a number x\r\nunsigned int countSetBitsUtil(unsigned int x);\r\n \r\n// Returns count of set bits present in all numbers from 1 to n\r\nunsigned int countSetBits(unsigned int n)\r\n{\r\n    int bitCount = 0; // initialize the result\r\n \r\n    for(int i = 1; i <= n; i++)\r\n       bitCount += countSetBitsUtil(i);\r\n \r\n    return bitCount;\r\n}\r\n \r\n// A utility function to count set bits in a number x\r\nunsigned int countSetBitsUtil(unsigned int x)\r\n{\r\n    if (x <= 0)\r\n        return 0;\r\n    return (x %2 == 0? 0: 1) + countSetBitsUtil (x/2);\r\n}\r\n \r\n// Driver program to test above functions\r\nint main()\r\n{\r\n   int n = 4;\r\n   printf ("Total set bit count is %d", countSetBits(n));\r\n   return 0;\r\n}', 'Time Complexity: O(Logn). From the first look at the implementation, time complexity looks more. But if we take a closer look, statements inside while loop of getNextLeftmostBit() are executed for all 0 bits in n. And the number of times recursion is executed is less than or equal to set bits in n. In other words, if the control goes inside while loop of getNextLeftmostBit(), then it skips those many bits in recursion.\r\n\r\nThanks to agatsu and IC for suggesting this solution.\r\n\r\nSee this for another solution suggested by Piyush Kapoor.\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above', 'Bit Magic', 'Bit', 10),
(24, 'Tarango Khan', '2015-07-22', 'Swap bits in a given number', 'Given a number x and two positions (from right side) in binary representation of x, write a function that swaps n bits at given two positions and returns the result.', '#include<stdio.h>\r\n \r\nint swapBits(unsigned int x, unsigned int p1, unsigned int p2, unsigned int n)\r\n{\r\n    /* Move all bits of first set to rightmost side */\r\n    unsigned int set1 =  (x >> p1) & ((1U << n) - 1);\r\n \r\n    /* Moce all bits of second set to rightmost side */\r\n    unsigned int set2 =  (x >> p2) & ((1U << n) - 1);\r\n \r\n    /* XOR the two sets */\r\n    unsigned int xor = (set1 ^ set2);\r\n \r\n    /* Put the xor bits back to their original positions */\r\n    xor = (xor << p1) | (xor << p2);\r\n \r\n    /* XOR the ''xor'' with the original number so that the \r\n       two sets are swapped */\r\n    unsigned int result = x ^ xor;\r\n \r\n    return result;\r\n}\r\n \r\n/* Drier program to test above function*/\r\nint main()\r\n{\r\n    int res =  swapBits(28, 0, 3, 2);\r\n    printf("\\nResult = %d ", res);\r\n    return 0;\r\n}', 'Given a number x and two positions (from right side) in binary representation of x, write a function that swaps n bits at given two positions and returns the result. It is also given that the two sets of bits do not overlap.\r\n\r\nExamples:\r\n\r\nLet p1 and p2 be the two given positions.\r\n\r\nExample 1\r\nInput:\r\nx = 47 (00101111)\r\np1 = 1 (Start from second bit from right side)\r\np2 = 5 (Start from 6th bit from right side)\r\nn = 3 (No of bits to be swapped)\r\nOutput:\r\n227 (11100011)\r\nThe 3 bits starting from the second bit (from right side) are \r\nswapped with 3 bits starting from 6th position (from right side) \r\n\r\n\r\nExample 2\r\nInput:\r\nx = 28 (11100)\r\np1 = 0 (Start from first bit from right side)\r\np2 = 3 (Start from 4th bit from right side)\r\nn = 2 (No of bits to be swapped)\r\nOutput:\r\n7 (00111)\r\nThe 2 bits starting from 0th postion (from right side) are\r\nswapped with 2 bits starting from 4th position (from right side) \r\nSolution\r\nWe need to swap two sets of bits. XOR can be used in a similar way as it is used to swap 2 numbers. Following is the algorithm.\r\n\r\n1) Move all bits of first set to rightmost side\r\n   set1 =  (x >> p1) & ((1U << n) - 1)\r\nHere the expression (1U << n) - 1 gives a number that \r\ncontains last n bits set and other bits as 0. We do & \r\nwith this expression so that bits other than the last \r\nn bits become 0.\r\n2) Move all bits of second set to rightmost side\r\n   set2 =  (x >> p2) & ((1U << n) - 1)\r\n3) XOR the two sets of bits\r\n   xor = (set1 ^ set2) \r\n4) Put the xor bits back to their original positions. \r\n   xor = (xor << p1) | (xor << p2)\r\n5) Finally, XOR the xor with original number so \r\n   that the two sets are swapped.\r\n   result = x ^ xor', 'Following is a shorter implementation of the same logic\r\n\r\nint swapBits(unsigned int x, unsigned int p1, unsigned int p2, unsigned int n)\r\n{\r\n    /* xor contains xor of two sets */\r\n    unsigned int xor = ((x >> p1) ^ (x >> p2)) & ((1U << n) - 1);\r\n \r\n    /* To swap two sets, we need to again XOR the xor with original sets */\r\n    return x ^ ((xor << p1) | (xor << p2));\r\n}', 'Bit Magic', 'Bit', 10),
(25, 'Tarango Khan', '2015-07-22', 'Add two numbers without using arithmetic operators', 'Write a function Add() that returns sum of two integers. The function should not use any of the arithmetic operators (+, ++, –, -, .. etc).', '#include<stdio.h>\r\n \r\nint Add(int x, int y)\r\n{\r\n    // Iterate till there is no carry  \r\n    while (y != 0)\r\n    {\r\n        // carry now contains common set bits of x and y\r\n        int carry = x & y;  \r\n \r\n        // Sum of bits of x and y where at least one of the bits is not set\r\n        x = x ^ y; \r\n \r\n        // Carry is shifted by one so that adding it to x gives the required sum\r\n        y = carry << 1;\r\n    }\r\n    return x;\r\n}\r\n \r\nint main()\r\n{\r\n    printf("%d", Add(15, 32));\r\n    return 0;\r\n}\r\n\r\nFollowing is recursive implementation for the same approach.\r\n\r\nint Add(int x, int y)\r\n{\r\n    if (y == 0)\r\n        return x;\r\n    else\r\n        return Add( x ^ y, (x & y) << 1);\r\n}', 'Write a function Add() that returns sum of two integers. The function should not use any of the arithmetic operators (+, ++, –, -, .. etc).\r\n\r\nSum of two bits can be obtained by performing XOR (^) of the two bits. Carry bit can be obtained by performing AND (&) of two bits.\r\nAbove is simple Half Adder logic that can be used to add 2 single bits. We can extend this logic for integers. If x and y don’t have set bits at same position(s), then bitwise XOR (^) of x and y gives the sum of x and y. To incorporate common set bits also, bitwise AND (&) is used. Bitwise AND of x and y gives all carry bits. We calculate (x & y) << 1 and add it to x ^ y to get the required result.', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Bit Magic', 'Bit', 10),
(26, 'Tarango Khan', '2015-07-22', 'Smallest of three integers without comparison operators', 'Write a C program to find the smallest of three integers, without using any of the comparison operators.\r\n\r\nLet 3 input numbers be x, y and z.', 'Method 2 (Use Bit Operations)\r\nUse method 2 of this post to find minimum of two numbers (We can’t use Method 1 as Method 1 uses comparison operator). Once we have functionality to find minimum of 2 numbers, we can use this to find minimum of 3 numbers.\r\n\r\n// See mthod 2 of http://www.geeksforgeeks.org/archives/2643\r\n#include<stdio.h>\r\n#define CHAR_BIT 8\r\n \r\n/*Function to find minimum of x and y*/\r\nint min(int x, int y)\r\n{\r\n  return  y + ((x - y) & ((x - y) >>\r\n            (sizeof(int) * CHAR_BIT - 1)));\r\n}\r\n \r\n/* Function to find minimum of 3 numbers x, y and z*/\r\nint smallest(int x, int y, int z)\r\n{\r\n    return min(x, min(y, z));\r\n}\r\n \r\nint main()\r\n{\r\n   int x = 12, y = 15, z = 5;\r\n   printf("Minimum of 3 numbers is %d", smallest(x, y, z));\r\n   return 0;\r\n}', 'Method 1 (Repeated Subtraction)\r\nTake a counter variable c and initialize it with 0. In a loop, repeatedly subtract x, y and z by 1 and increment c. The number which becomes 0 first is the smallest. After the loop terminates, c will hold the minimum of 3.\r\n\r\n#include<stdio.h>\r\n \r\nint smallest(int x, int y, int z)\r\n{\r\n  int c = 0;\r\n  while ( x && y && z )\r\n  {\r\n      x--;  y--; z--; c++;\r\n  }\r\n  return c;\r\n}\r\n \r\nint main()\r\n{\r\n   int x = 12, y = 15, z = 5;\r\n   printf("Minimum of 3 numbers is %d", smallest(x, y, z));\r\n   return 0;\r\n}', 'Method 3 (Use Division operator)\r\nWe can also use division operator to find minimum of two numbers. If value of (a/b) is zero, then b is greater than a, else a is greater. Thanks to gopinath and Vignesh for suggesting this method.\r\n\r\n#include <stdio.h>\r\n \r\n// Using division operator to find minimum of three numbers\r\nint smallest(int x, int y, int z)\r\n{\r\n    if (!(y/x))  // Same as "if (y < x)"\r\n        return (!(y/z))? y : z;\r\n    return (!(x/z))? x : z;\r\n}\r\n \r\nint main()\r\n{\r\n    int x = 78, y = 88, z = 68;\r\n    printf("Minimum of 3 numbers is %d", smallest(x, y, z));\r\n    return 0;\r\n}', 'Bit Magic', 'Bit', 10);
INSERT INTO `algorithms` (`algo_id`, `author`, `date`, `title`, `short_note`, `code`, `description`, `analysis`, `category`, `tags`, `View`) VALUES
(27, 'Tarango Khan', '2015-07-22', 'Topological Sorting', 'Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge uv, vertex u comes before v in the ordering', 'Following is C++ implementation of topological sorting. Please see the code for Depth First Traversal for a disconnected Graph and note the differences between the second code given there and the below code.\r\n\r\n// A C++ program to print topological sorting of a DAG\r\n#include<iostream>\r\n#include <list>\r\n#include <stack>\r\nusing namespace std;\r\n \r\n// Class to represent a graph\r\nclass Graph\r\n{\r\n    int V;    // No. of vertices''\r\n \r\n    // Pointer to an array containing adjacency listsList\r\n    list<int> *adj;\r\n \r\n    // A function used by topologicalSort\r\n    void topologicalSortUtil(int v, bool visited[], stack<int> &Stack);\r\npublic:\r\n    Graph(int V);   // Constructor\r\n \r\n     // function to add an edge to graph\r\n    void addEdge(int v, int w);\r\n \r\n    // prints a Topological Sort of the complete graph\r\n    void topologicalSort();\r\n};\r\n \r\nGraph::Graph(int V)\r\n{\r\n    this->V = V;\r\n    adj = new list<int>[V];\r\n}\r\n \r\nvoid Graph::addEdge(int v, int w)\r\n{\r\n    adj[v].push_back(w); // Add w to v’s list.\r\n}\r\n \r\n// A recursive function used by topologicalSort\r\nvoid Graph::topologicalSortUtil(int v, bool visited[], stack<int> &Stack)\r\n{\r\n    // Mark the current node as visited.\r\n    visited[v] = true;\r\n \r\n    // Recur for all the vertices adjacent to this vertex\r\n    list<int>::iterator i;\r\n    for (i = adj[v].begin(); i != adj[v].end(); ++i)\r\n        if (!visited[*i])\r\n            topologicalSortUtil(*i, visited, Stack);\r\n \r\n    // Push current vertex to stack which stores result\r\n    Stack.push(v);\r\n}\r\n \r\n// The function to do Topological Sort. It uses recursive topologicalSortUtil()\r\nvoid Graph::topologicalSort()\r\n{\r\n    stack<int> Stack;\r\n \r\n    // Mark all the vertices as not visited\r\n    bool *visited = new bool[V];\r\n    for (int i = 0; i < V; i++)\r\n        visited[i] = false;\r\n \r\n    // Call the recursive helper function to store Topological Sort\r\n    // starting from all vertices one by one\r\n    for (int i = 0; i < V; i++)\r\n      if (visited[i] == false)\r\n        topologicalSortUtil(i, visited, Stack);\r\n \r\n    // Print contents of stack\r\n    while (Stack.empty() == false)\r\n    {\r\n        cout << Stack.top() << " ";\r\n        Stack.pop();\r\n    }\r\n}\r\n \r\n// Driver program to test above functions\r\nint main()\r\n{\r\n    // Create a graph given in the above diagram\r\n    Graph g(6);\r\n    g.addEdge(5, 2);\r\n    g.addEdge(5, 0);\r\n    g.addEdge(4, 0);\r\n    g.addEdge(4, 1);\r\n    g.addEdge(2, 3);\r\n    g.addEdge(3, 1);\r\n \r\n    cout << "Following is a Topological Sort of the given graph \\n";\r\n    g.topologicalSort();\r\n \r\n    return 0;\r\n}', 'Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge uv, vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG.\r\nFor example, a topological sorting of the following graph is “5 4 2 3 1 0?. There can be more than one topological sorting for a graph. For example, another topological sorting of the following graph is “4 5 2 3 1 0?. The first vertex in topological sorting is always a vertex with in-degree as 0 (a vertex with no in-coming edges).\r\n\r\ngraph\r\n\r\nTopological Sorting vs Depth First Traversal (DFS):\r\nIn DFS, we print a vertex and then recursively call DFS for its adjacent vertices. In topological sorting, we need to print a vertex before its adjacent vertices. For example, in the given graph, the vertex ‘5’ should be printed before vertex ‘0’, but unlike DFS, the vertex ‘4’ should also be printed before vertex ‘0’. So Topological sorting is different from DFS. For example, a DFS of the above graph is “5 2 3 1 0 4?, but it is not a topological sorting\r\n\r\nAlgorithm to find Topological Sorting:\r\nWe recommend to first see implementation of DFS here. We can modify DFS to find Topological Sorting of a graph. In DFS, we start from a vertex, we first print it and then recursively call DFS for its adjacent vertices. In topological sorting, we use a temporary stack. We don’t print the vertex immediately, we first recursively call topological sorting for all its adjacent vertices, then push it to a stack. Finally, print contents of stack. Note that a vertex is pushed to stack only when all of its adjacent vertices (and their adjacent vertices and so on) are already in stack.', 'Time Complexity: The above algorithm is simply DFS with an extra stack. So time complexity is same as DFS which is O(V+E).\r\n\r\nApplications:\r\nTopological Sorting is mainly used for scheduling jobs from the given dependencies among jobs. In computer science, applications of this type arise in instruction scheduling, ordering of formula cell evaluation when recomputing formula values in spreadsheets, logic synthesis, determining the order of compilation tasks to perform in makefiles, data serialization, and resolving symbol dependencies in linkers [2].\r\n\r\nReferences:\r\nhttp://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/topoSort.htm\r\nhttp://en.wikipedia.org/wiki/Topological_sorting\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above', 'Graph', 'Graph', 10),
(28, 'Tarango Khan', '2015-07-22', 'Breadth First Traversal for a Graph', 'Breadth First Traversal (or Search) for a graph is similar to Breadth First Traversal of a tree (See mthod 2 of this post). ', 'Following is C++ implementation of simple Breadth First Traversal from a given source. The implementation uses adjacency list representation of graphs. STL‘s list container is used to store lists of adjacent nodes and queue of nodes needed for BFS traversal.\r\n\r\n// Program to print BFS traversal from a given source vertex. BFS(int s) \r\n// traverses vertices reachable from s.\r\n#include<iostream>\r\n#include <list>\r\n \r\nusing namespace std;\r\n \r\n// This class represents a directed graph using adjacency list representation\r\nclass Graph\r\n{\r\n    int V;    // No. of vertices\r\n    list<int> *adj;    // Pointer to an array containing adjacency lists\r\npublic:\r\n    Graph(int V);  // Constructor\r\n    void addEdge(int v, int w); // function to add an edge to graph\r\n    void BFS(int s);  // prints BFS traversal from a given source s\r\n};\r\n \r\nGraph::Graph(int V)\r\n{\r\n    this->V = V;\r\n    adj = new list<int>[V];\r\n}\r\n \r\nvoid Graph::addEdge(int v, int w)\r\n{\r\n    adj[v].push_back(w); // Add w to v’s list.\r\n}\r\n \r\nvoid Graph::BFS(int s)\r\n{\r\n    // Mark all the vertices as not visited\r\n    bool *visited = new bool[V];\r\n    for(int i = 0; i < V; i++)\r\n        visited[i] = false;\r\n \r\n    // Create a queue for BFS\r\n    list<int> queue;\r\n \r\n    // Mark the current node as visited and enqueue it\r\n    visited[s] = true;\r\n    queue.push_back(s);\r\n \r\n    // ''i'' will be used to get all adjacent vertices of a vertex\r\n    list<int>::iterator i;\r\n \r\n    while(!queue.empty())\r\n    {\r\n        // Dequeue a vertex from queue and print it\r\n        s = queue.front();\r\n        cout << s << " ";\r\n        queue.pop_front();\r\n \r\n        // Get all adjacent vertices of the dequeued vertex s\r\n        // If a adjacent has not been visited, then mark it visited\r\n        // and enqueue it\r\n        for(i = adj[s].begin(); i != adj[s].end(); ++i)\r\n        {\r\n            if(!visited[*i])\r\n            {\r\n                visited[*i] = true;\r\n                queue.push_back(*i);\r\n            }\r\n        }\r\n    }\r\n}\r\n \r\n// Driver program to test methods of graph class\r\nint main()\r\n{\r\n    // Create a graph given in the above diagram\r\n    Graph g(4);\r\n    g.addEdge(0, 1);\r\n    g.addEdge(0, 2);\r\n    g.addEdge(1, 2);\r\n    g.addEdge(2, 0);\r\n    g.addEdge(2, 3);\r\n    g.addEdge(3, 3);\r\n \r\n    cout << "Following is Breadth First Traversal (starting from vertex 2) \\n";\r\n    g.BFS(2);\r\n \r\n    return 0;\r\n}', 'Breadth First Traversal (or Search) for a graph is similar to Breadth First Traversal of a tree (See mthod 2 of this post). The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again. To avoid processing a node more than once, we use a boolean visited array. For simplicity, it is assumed that all vertices are reachable from the starting vertex.\r\nFor example, in the following graph, we start traversal from vertex 2. When we come to vertex 0, we look for all adjacent vertices of it. 2 is also an adjacent vertex of 0. If we don’t mark visited vertices, then 2 will be processed again and it will become a non-terminating process. Breadth First Traversal of the following graph is 2, 0, 3, 1.', 'Note that the above code traverses only the vertices reachable from a given source vertex. All the vertices may not be reachable from a given vertex (example Disconnected graph). To print all the vertices, we can modify the BFS function to do traversal starting from all nodes one by one (Like the DFS modified version) .\r\n\r\nTime Complexity: O(V+E) where V is number of vertices in the graph and E is number of edges in the graph.\r\n\r\nAlso see Depth First Traversal\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Graph', 'Graph', 10),
(29, 'Tarango Khan', '2015-07-23', 'Heap Sort', 'Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element ', '// C implementation of Heap Sort\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n \r\n// A heap has current size and array of elements\r\nstruct MaxHeap\r\n{\r\n    int size;\r\n    int* array;\r\n};\r\n \r\n// A utility function to swap to integers\r\nvoid swap(int* a, int* b) { int t = *a; *a = *b;  *b = t; }\r\n \r\n// The main function to heapify a Max Heap. The function \r\n// assumes that everything under given root (element at \r\n// index idx) is already heapified\r\nvoid maxHeapify(struct MaxHeap* maxHeap, int idx)\r\n{\r\n    int largest = idx;  // Initialize largest as root\r\n    int left = (idx << 1) + 1;  // left = 2*idx + 1\r\n    int right = (idx + 1) << 1; // right = 2*idx + 2\r\n \r\n    // See if left child of root exists and is greater than\r\n    // root\r\n    if (left < maxHeap->size && \r\n        maxHeap->array[left] > maxHeap->array[largest])\r\n        largest = left;\r\n \r\n    // See if right child of root exists and is greater than\r\n    // the largest so far\r\n    if (right < maxHeap->size && \r\n        maxHeap->array[right] > maxHeap->array[largest])\r\n        largest = right;\r\n \r\n    // Change root, if needed\r\n    if (largest != idx)\r\n    {\r\n        swap(&maxHeap->array[largest], &maxHeap->array[idx]);\r\n        maxHeapify(maxHeap, largest);\r\n    }\r\n}\r\n \r\n// A utility function to create a max heap of given capacity\r\nstruct MaxHeap* createAndBuildHeap(int *array, int size)\r\n{\r\n    int i;\r\n    struct MaxHeap* maxHeap = \r\n              (struct MaxHeap*) malloc(sizeof(struct MaxHeap));\r\n    maxHeap->size = size;   // initialize size of heap\r\n    maxHeap->array = array; // Assign address of first element of array\r\n \r\n    // Start from bottommost and rightmost internal mode and heapify all\r\n    // internal modes in bottom up way\r\n    for (i = (maxHeap->size - 2) / 2; i >= 0; --i)\r\n        maxHeapify(maxHeap, i);\r\n    return maxHeap;\r\n}\r\n \r\n// The main function to sort an array of given size\r\nvoid heapSort(int* array, int size)\r\n{\r\n    // Build a heap from the input data.\r\n    struct MaxHeap* maxHeap = createAndBuildHeap(array, size);\r\n \r\n    // Repeat following steps while heap size is greater than 1. \r\n    // The last element in max heap will be the minimum element\r\n    while (maxHeap->size > 1)\r\n    {\r\n        // The largest item in Heap is stored at the root. Replace\r\n        // it with the last item of the heap followed by reducing the\r\n        // size of heap by 1.\r\n        swap(&maxHeap->array[0], &maxHeap->array[maxHeap->size - 1]);\r\n        --maxHeap->size;  // Reduce heap size\r\n \r\n        // Finally, heapify the root of tree.\r\n        maxHeapify(maxHeap, 0);\r\n    }\r\n}\r\n \r\n// A utility function to print a given array of given size\r\nvoid printArray(int* arr, int size)\r\n{\r\n    int i;\r\n    for (i = 0; i < size; ++i)\r\n        printf("%d ", arr[i]);\r\n}\r\n \r\n/* Driver program to test above functions */\r\nint main()\r\n{\r\n    int arr[] = {12, 11, 13, 5, 6, 7};\r\n    int size = sizeof(arr)/sizeof(arr[0]);\r\n \r\n    printf("Given array is \\n");\r\n    printArray(arr, size);\r\n \r\n    heapSort(arr, size);\r\n \r\n    printf("\\nSorted array is \\n");\r\n    printArray(arr, size);\r\n    return 0;\r\n}', 'Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end. We repeat the same process for remaining element.\r\nWhat is Binary Heap?\r\nLet us first define a Complete Binary Tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible (Source Wikipedia)\r\nA Binary Heap is a Complete Binary Tree where items are stored in a special order such that value in a parent node is greater(or smaller) than the values in its two children nodes. The former is called as max heap and the latter is called min heap. The heap can be represented by binary tree or array.\r\nWhy array based representation for Binary Heap?\r\nSince a Binary Heap is a Complete Binary Tree, it can be easily represented as array and array based representation is space efficient. If the parent node is stored at index I, the left child can be calculated by 2 * I + 1 and right child by 2 * I + 2.\r\nHeap Sort Algorithm for sorting in increasing order:\r\n1. Build a max heap from the input data.\r\n2. At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of tree.\r\n3. Repeat above steps until size of heap is greater than 1.\r\nHow to build the heap?\r\nHeapify procedure can be applied to a node only if its children nodes are heapified. So the heapification must be performed in the bottom up order.\r\nLets understand with the help of an example:\r\nInput data: 4, 10, 3, 5, 1\r\n                 4(0)\r\n		/   \\\r\n	     10(1)   3(2)\r\n            /   \\\r\n	 5(3)    1(4)\r\n\r\nThe numbers in bracket represent the indices in the array \r\nrepresentation of data.\r\n\r\nApplying heapify procedure to index 1:\r\n 		4(0)\r\n		/   \\\r\n            10(1)    3(2)\r\n           /   \\\r\n	5(3)    1(4)\r\n\r\nApplying heapify procedure to index 0:\r\n	        10(0)\r\n		/  \\\r\n	     5(1)  3(2)\r\n            /   \\\r\n         4(3)    1(4)\r\nThe heapify procedure calls itself recursively to build heap\r\n in top down manner.', 'Notes:\r\nHeap sort is an in-place algorithm.\r\nIts typical implementation is not stable, but can be made stable (See this)\r\nTime Complexity: Time complexity of heapify is O(Logn). Time complexity of createAndBuildHeap() is O(n) and overall time complexity of Heap Sort is O(nLogn).\r\nApplications of HeapSort\r\n1. Sort a nearly sorted (or K sorted) array\r\n2. k largest(or smallest) elements in an array\r\nHeap sort algorithm has limited uses because Quicksort and Mergesort are better in practice. Nevertheless, the Heap data structure itself is enormously used. See Applications of Heap Data Structure\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Data Structure', 'Data Structure', 10),
(30, 'Tarango Khan', '2015-07-23', 'Priority Queue | Set 1 (Introduction)', 'Priority Queue is an extension of queue with following properties.', '', 'Priority Queue is an extension of queue with following properties.\r\n1) Every item has a priority associated with it.\r\n2) An element with high priority is dequeued before an element with low priority.\r\n3) If two elements have the same priority, they are served according to their order in the queue.\r\nA typical priority queue supports following operations.\r\ninsert(item, priority): Inserts an item with given priority.\r\ngetHighestPriority(): Returns the highest priority item.\r\ndeleteHighestPriority(): Removes the highest priority item.\r\nHow to implement priority queue?\r\nUsing Array: A simple implementation is to use array of following structure.\r\nstruct item {\r\n   int item;\r\n   int priority;\r\n}\r\ninsert() operation can be implemented by adding an item at end of array in O(1) time.\r\ngetHighestPriority() operation can be implemented by linearly searching the highest priority item in array. This operation takes O(n) time.\r\ndeleteHighestPriority() operation can be implemented by first linearly searching an item, then removing the item by moving all subsequent items one position back.\r\nWe can also use Linked List, time complexity of all operations with linked list remains same as array. The advantage with linked list is deleteHighestPriority() can be more efficient as we don’t have to move items.\r\nUsing Heaps:\r\nHeap is generally preferred for priority queue implementation because heaps provide better performance compared arrays or linked list. In a Binary Heap, getHighestPriority() can be implemented in O(1) time, insert() can be implemented in O(Logn) time and deleteHighestPriority() can also be implemented in O(Logn) time.\r\nWith Fibonacci heap, insert() and getHighestPriority() can be implemented in O(1) amortized time and deleteHighestPriority() can be implemented in O(Logn) amortized time.\r\nApplications of Priority Queue:\r\n1) CPU Scheduling\r\n2) Graph algorithms like Dijkstra’s shortest path algorithm, Prim’s Minimum Spanning Tree, etc\r\n3) All queue applications where priority is involved.\r\nWe will soon be discussing array and heap implementations of priority queue.\r\nReferences:\r\nhttp://en.wikipedia.org/wiki/Priority_queue\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', '', 'Data Structure', 'Data Structure', 10),
(31, 'Tarango Khan', '2015-07-23', 'Segment Tree | Set 1 (Sum of given range)', 'Let us consider the following problem to understand Segment Trees.', 'Implementation:\r\nFollowing is implementation of segment tree. The program implements construction of segment tree for any given array. It also implements query and update operations.\r\n\r\n// Program to show segment tree operations like construction, query and update\r\n#include <stdio.h>\r\n#include <math.h>\r\n \r\n// A utility function to get the middle index from corner indexes.\r\nint getMid(int s, int e) {  return s + (e -s)/2;  }\r\n \r\n/*  A recursive function to get the sum of values in given range of the array.\r\n    The following are parameters for this function.\r\n \r\n    st    --> Pointer to segment tree\r\n    index --> Index of current node in the segment tree. Initially 0 is\r\n             passed as root is always at index 0\r\n    ss & se  --> Starting and ending indexes of the segment represented by\r\n                 current node, i.e., st[index]\r\n    qs & qe  --> Starting and ending indexes of query range */\r\nint getSumUtil(int *st, int ss, int se, int qs, int qe, int index)\r\n{\r\n    // If segment of this node is a part of given range, then return the \r\n    // sum of the segment\r\n    if (qs <= ss && qe >= se)\r\n        return st[index];\r\n \r\n    // If segment of this node is outside the given range\r\n    if (se < qs || ss > qe)\r\n        return 0;\r\n \r\n    // If a part of this segment overlaps with the given range\r\n    int mid = getMid(ss, se);\r\n    return getSumUtil(st, ss, mid, qs, qe, 2*index+1) +\r\n           getSumUtil(st, mid+1, se, qs, qe, 2*index+2);\r\n}\r\n \r\n/* A recursive function to update the nodes which have the given index in\r\n   their range. The following are parameters\r\n    st, index, ss and se are same as getSumUtil()\r\n    i    --> index of the element to be updated. This index is in input array.\r\n   diff --> Value to be added to all nodes which have i in range */\r\nvoid updateValueUtil(int *st, int ss, int se, int i, int diff, int index)\r\n{\r\n    // Base Case: If the input index lies outside the range of this segment\r\n    if (i < ss || i > se)\r\n        return;\r\n \r\n    // If the input index is in range of this node, then update the value\r\n    // of the node and its children\r\n    st[index] = st[index] + diff;\r\n    if (se != ss)\r\n    {\r\n        int mid = getMid(ss, se);\r\n        updateValueUtil(st, ss, mid, i, diff, 2*index + 1);\r\n        updateValueUtil(st, mid+1, se, i, diff, 2*index + 2);\r\n    }\r\n}\r\n \r\n// The function to update a value in input array and segment tree.\r\n// It uses updateValueUtil() to update the value in segment tree\r\nvoid updateValue(int arr[], int *st, int n, int i, int new_val)\r\n{\r\n    // Check for erroneous input index\r\n    if (i < 0 || i > n-1)\r\n    {\r\n        printf("Invalid Input");\r\n        return;\r\n    }\r\n \r\n    // Get the difference between new value and old value\r\n    int diff = new_val - arr[i];\r\n \r\n    // Update the value in array\r\n    arr[i] = new_val;\r\n \r\n    // Update the values of nodes in segment tree\r\n    updateValueUtil(st, 0, n-1, i, diff, 0);\r\n}\r\n \r\n// Return sum of elements in range from index qs (quey start) to\r\n// qe (query end).  It mainly uses getSumUtil()\r\nint getSum(int *st, int n, int qs, int qe)\r\n{\r\n    // Check for erroneous input values\r\n    if (qs < 0 || qe > n-1 || qs > qe)\r\n    {\r\n        printf("Invalid Input");\r\n        return -1;\r\n    }\r\n \r\n    return getSumUtil(st, 0, n-1, qs, qe, 0);\r\n}\r\n \r\n// A recursive function that constructs Segment Tree for array[ss..se].\r\n// si is index of current node in segment tree st\r\nint constructSTUtil(int arr[], int ss, int se, int *st, int si)\r\n{\r\n    // If there is one element in array, store it in current node of\r\n    // segment tree and return\r\n    if (ss == se)\r\n    {\r\n        st[si] = arr[ss];\r\n        return arr[ss];\r\n    }\r\n \r\n    // If there are more than one elements, then recur for left and\r\n    // right subtrees and store the sum of values in this node\r\n    int mid = getMid(ss, se);\r\n    st[si] =  constructSTUtil(arr, ss, mid, st, si*2+1) +\r\n              constructSTUtil(arr, mid+1, se, st, si*2+2);\r\n    return st[si];\r\n}\r\n \r\n/* Function to construct segment tree from given array. This function\r\n   allocates memory for segment tree and calls constructSTUtil() to\r\n   fill the allocated memory */\r\nint *constructST(int arr[], int n)\r\n{\r\n    // Allocate memory for segment tree\r\n    int x = (int)(ceil(log2(n))); //Height of segment tree\r\n    int max_size = 2*(int)pow(2, x) - 1; //Maximum size of segment tree\r\n    int *st = new int[max_size];\r\n \r\n    // Fill the allocated memory st\r\n    constructSTUtil(arr, 0, n-1, st, 0);\r\n \r\n    // Return the constructed segment tree\r\n    return st;\r\n}\r\n \r\n// Driver program to test above functions\r\nint main()\r\n{\r\n    int arr[] = {1, 3, 5, 7, 9, 11};\r\n    int n = sizeof(arr)/sizeof(arr[0]);\r\n \r\n    // Build segment tree from given array\r\n    int *st = constructST(arr, n);\r\n \r\n    // Print sum of values in array from index 1 to 3\r\n    printf("Sum of values in given range = %d\\n", getSum(st, n, 1, 3));\r\n \r\n    // Update: set arr[1] = 10 and update corresponding segment\r\n    // tree nodes\r\n    updateValue(arr, st, n, 1, 10);\r\n \r\n    // Find sum after the value is updated\r\n    printf("Updated sum of values in given range = %d\\n",\r\n                                                  getSum(st, n, 1, 3));\r\n \r\n    return 0;\r\n}', 'Let us consider the following problem to understand Segment Trees.\r\n\r\nWe have an array arr[0 . . . n-1]. We should be able to\r\n1 Find the sum of elements from index l to r where 0 <= l <= r <= n-1\r\n2 Change value of a specified element of the array arr[i] = x where 0 <= i <= n-1.\r\n\r\nA simple solution is to run a loop from l to r and calculate sum of elements in given range. To update a value, simply do arr[i] = x. The first operation takes O(n) time and second operation takes O(1) time.\r\n\r\nAnother solution is to create another array and store sum from start to i at the ith index in this array. Sum of a given range can now be calculated in O(1) time, but update operation takes O(n) time now. This works well if the number of query operations are large and very few updates.\r\n\r\nWhat if the number of query and updates are equal? Can we perform both the operations in O(log n) time once given the array? We can use a Segment Tree to do both operations in O(Logn) time.\r\n\r\nRepresentation of Segment trees\r\n1. Leaf Nodes are the elements of the input array.\r\n2. Each internal node represents some merging of the leaf nodes. The merging may be different for different problems. For this problem, merging is sum of leaves under a node.\r\n\r\nAn array representation of tree is used to represent Segment Trees. For each node at index i, the left child is at index 2*i+1, right child at 2*i+2 and the parent is at st1.\r\n\r\n\r\n\r\nConstruction of Segment Tree from given array\r\nWe start with a segment arr[0 . . . n-1]. and every time we divide the current segment into two halves(if it has not yet become a segment of length 1), and then call the same procedure on both halves, and for each such segment we store the sum in corresponding node.\r\nAll levels of the constructed segment tree will be completely filled except the last level. Also, the tree will be a Full Binary Tree because we always divide segments in two halves at every level. Since the constructed tree is always full binary tree with n leaves, there will be n-1 internal nodes. So total number of nodes will be 2*n – 1.\r\nHeight of the segment tree will be st2. Since the tree is represented using array and relation between parent and child indexes must be maintained, size of memory allocated for segment tree will be st3.\r\n\r\nQuery for Sum of given range\r\nOnce the tree is constructed, how to get the sum using the constructed segment tree. Following is algorithm to get the sum of elements.\r\n\r\nint getSum(node, l, r) \r\n{\r\n   if range of node is within l and r\r\n        return value in node\r\n   else if range of node is completely outside l and r\r\n        return 0\r\n   else\r\n    return getSum(node''s left child, l, r) + \r\n           getSum(node''s right child, l, r)\r\n}\r\nUpdate a value\r\nLike tree construction and query operations, update can also be done recursively. We are given an index which needs to updated. Let diff be the value to be added. We start from root of the segment tree, and add diff to all nodes which have given index in their range. If a node doesn’t have given index in its range, we don’t make any changes to that node.', 'Time Complexity:\r\nTime Complexity for tree construction is O(n). There are total 2n-1 nodes, and value of every node is calculated only once in tree construction.\r\n\r\nTime complexity to query is O(Logn). To query a sum, we process at most four nodes at every level and number of levels is O(Logn).\r\n\r\nThe time complexity of update is also O(Logn). To update a leaf value, we process one node at every level and number of levels is O(Logn).\r\n\r\n\r\nSegment Tree | Set 2 (Range Minimum Query)\r\n\r\nReferences:\r\nhttp://www.cse.iitk.ac.in/users/aca/lop12/slides/06.pdf\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Data Structure', 'Data Structure', 10),
(32, 'Tarango Khan', '2015-07-23', 'Binary Tree | Set 1 (Introduction)', 'Trees: Unlike Arrays, Linked Lists, Stack and queues, which are linear data structures, trees are hierarchical data structures.', 'First Simple Tree in C\r\nLet us create a simple tree with 4 nodes in C. The created tree would be as following.\r\n      tree\r\n      ----\r\n       1    <-- root\r\n     /   \\\r\n    2     3  \r\n   /   \r\n  4\r\nstruct node \r\n{\r\n    int data;\r\n    struct node *left;\r\n    struct node *right;\r\n};\r\n \r\n/* newNode() allocates a new node with the given data and NULL left and \r\n   right pointers. */\r\nstruct node* newNode(int data)\r\n{\r\n  // Allocate memory for new node \r\n  struct node* node = (struct node*)malloc(sizeof(struct node));\r\n \r\n  // Assign data to this node\r\n  node->data = data;\r\n \r\n  // Initialize left and right children as NULL\r\n  node->left = NULL;\r\n  node->right = NULL;\r\n  return(node);\r\n}\r\n \r\n \r\nint main()\r\n{\r\n  /*create root*/\r\n  struct node *root = newNode(1);  \r\n  /* following is the tree after above statement \r\n \r\n        1\r\n      /   \\\r\n     NULL  NULL  \r\n  */\r\n   \r\n \r\n  root->left        = newNode(2);\r\n  root->right       = newNode(3);\r\n  /* 2 and 3 become left and right children of 1\r\n           1\r\n         /   \\\r\n        2      3\r\n     /    \\    /  \\\r\n    NULL NULL NULL NULL\r\n  */\r\n \r\n \r\n  root->left->left  = newNode(4);\r\n  /* 4 becomes left child of 2\r\n           1\r\n       /       \\\r\n      2          3\r\n    /   \\       /  \\\r\n   4    NULL  NULL  NULL\r\n  /  \\\r\nNULL NULL\r\n*/\r\n \r\n  getchar();\r\n  return 0;\r\n}', 'Trees: Unlike Arrays, Linked Lists, Stack and queues, which are linear data structures, trees are hierarchical data structures.\r\nTree Vocabulary: The topmost node is called root of the tree. The elements that are directly under an element are called its children. The element directly above something is called its parent. For example, a is a child of f and f is the parent of a. Finally, elements with no children are called leaves.\r\n      tree\r\n      ----\r\n       j    <-- root\r\n     /   \\\r\n    f      k  \r\n  /   \\      \\\r\n a     h      z    <-- leaves \r\nWhy Trees?\r\n1. One reason to use trees might be because you want to store information that naturally forms a hierarchy. For example, the file system on a computer:\r\nfile system\r\n-----------\r\n     /    <-- root\r\n  /      \\\r\n...       home\r\n      /          \\\r\n   ugrad        course\r\n    /       /      |     \\\r\n  ...      cs101  cs112  cs113  \r\n2. Trees (with some ordering e.g., BST) provide moderate access/search (quicker than Linked List and slower than arrays).\r\n3. Trees provide moderate insertion/deletion (quicker than Arrays and slower than Unordered Linked Lists).\r\n4. Like Linked Lists and unlike Arrays, Trees don’t have an upper limit on number of nodes as nodes are linked using pointers.\r\nMain applications of trees include:\r\n1. Manipulate hierarchical data.\r\n2. Make information easy to search (see tree traversal).\r\n3. Manipulate sorted lists of data.\r\n4. As a workflow for compositing digital images for visual effects.\r\n5. Router algorithms\r\n6. Form of a multi-stage decision-making (see business chess).\r\nBinary Tree: A tree whose elements have at most 2 children is called a binary tree. Since each element in a binary tree can have only 2 children, we typically name them the left and right child.\r\nBinary Tree Representation in C: A tree is represented by a pointer to the topmost node in tree. If the tree is empty, then value of root is NULL.\r\nA Tree node contains following parts.\r\n1. Data\r\n2. Pointer to left child\r\n3. Pointer to right child', 'Summary: Tree is a hierarchical data structure. Main uses of trees include maintaining hierarchical data, providing moderate access and insert/delete operations. Binary trees are special cases of tree where every node has at most two children.\r\nBelow are set 2 and set 3 of this post.\r\nProperties of Binary Tree\r\nTypes of Binary Tree\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Data Structure', 'Data Structure', 10),
(33, 'Tarango Khan', '2015-07-23', 'Red-Black Tree | Set 1 (Introduction)', 'Red-Black Tree is a self-balancing Binary Search Tree (BST) where every node follows following rules.', '// C program for Red-Black Tree insertion\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n \r\n//A Red-Black tree node structure\r\nstruct node\r\n{\r\n    int data;     // for data part\r\n    char color;  // for color property\r\n \r\n    //links for left, right children and parent\r\n    struct node *left, *right, *parent;\r\n};\r\n \r\n \r\n// Left Rotation\r\nvoid LeftRotate(struct node **root,struct node *x)\r\n{\r\n    //y stored pointer of right child of x\r\n    struct node *y = x->right;\r\n \r\n    //store y''s left subtree''s pointer as x''s right child\r\n    x->right = y->left;\r\n \r\n    //update parent pointer of x''s right\r\n    if (x->right != NULL)\r\n        x->right->parent = x;\r\n \r\n    //update y''s parent pointer\r\n    y->parent = x->parent;\r\n \r\n    // if x''s parent is null make y as root of tree\r\n    if (x->parent == NULL)\r\n        (*root) = y;\r\n \r\n    // store y at the place of x\r\n    else if (x == x->parent->left)\r\n        x->parent->left = y;\r\n    else    x->parent->right = y;\r\n \r\n    // make x as left child of y\r\n    y->left = x;\r\n \r\n    //update parent pointer of x\r\n    x->parent = y;\r\n}\r\n \r\n \r\n// Right Rotation (Similar to LeftRotate)\r\nvoid rightRotate(struct node **root,struct node *y)\r\n{\r\n    struct node *x = y->left;\r\n    y->left = x->right;\r\n    if (x->right != NULL)\r\n        x->right->parent = y;\r\n    x->parent =y->parent;\r\n    if (x->parent == NULL)\r\n        (*root) = x;\r\n    else if (y == y->parent->left)\r\n        y->parent->left = x;\r\n    else y->parent->right = x;\r\n    x->right = y;\r\n    y->parent = x;\r\n}\r\n \r\n// Utility function to fixup the Red-Black tree after standard BST insertion\r\nvoid insertFixUp(struct node **root,struct node *z)\r\n{\r\n    // iterate until z is not the root and z''s parent color is red\r\n    while (z != *root && z->parent->color == ''R'')\r\n    {\r\n        struct node *y;\r\n \r\n        // Find uncle and store uncle in y\r\n        if (z->parent == z->parent->parent->left)\r\n            y = z->parent->parent->right;\r\n        else\r\n            y = z->parent->parent->left;\r\n \r\n        // If uncle is RED, do following\r\n        // (i)  Change color of parent and uncle as BLACK\r\n        // (ii) Change color of grandparent as RED\r\n        // (iii) Move z to grandparent\r\n        if (y->color == ''R'')\r\n        {\r\n            y->color = ''B'';\r\n            z->parent->color = ''B'';\r\n            z->parent->parent->color = ''R'';\r\n            z = z->parent->parent;\r\n        }\r\n \r\n        // Uncle is BLACK, there are four cases (LL, LR, RL and RR)\r\n        else\r\n        {\r\n            // Left-Left (LL) case, do following\r\n            // (i)  Swap color of parent and grandparent\r\n            // (ii) Right Rotate Grandparent\r\n            if (z->parent == z->parent->parent->left &&\r\n                z == z->parent->left)\r\n            {\r\n                char ch = z->parent->color ;\r\n                z->parent->color = z->parent->parent->color;\r\n                z->parent->parent->color = ch;\r\n                rightRotate(root,z->parent->parent);\r\n            }\r\n \r\n            // Left-Right (LR) case, do following\r\n            // (i)  Swap color of current node  and grandparent\r\n            // (ii) Left Rotate Parent\r\n            // (iii) Right Rotate Grand Parent\r\n            if (z->parent == z->parent->parent->left &&\r\n                z == z->parent->right)\r\n            {\r\n                char ch = z->color ;\r\n                z->color = z->parent->parent->color;\r\n                z->parent->parent->color = ch;\r\n                LeftRotate(root,z->parent);\r\n                rightRotate(root,z->parent->parent);\r\n            }\r\n \r\n            // Right-Right (RR) case, do following\r\n            // (i)  Swap color of parent and grandparent\r\n            // (ii) Left Rotate Grandparent\r\n            if (z->parent == z->parent->parent->right &&\r\n                z == z->parent->right)\r\n            {\r\n                char ch = z->parent->color ;\r\n                z->parent->color = z->parent->parent->color;\r\n                z->parent->parent->color = ch;\r\n                LeftRotate(root,z->parent->parent);\r\n            }\r\n \r\n            // Right-Left (RL) case, do following\r\n            // (i)  Swap color of current node  and grandparent\r\n            // (ii) Right Rotate Parent\r\n            // (iii) Left Rotate Grand Parent\r\n            if (z->parent == z->parent->parent->right &&\r\n                z == z->parent->left)\r\n            {\r\n                char ch = z->color ;\r\n                z->color = z->parent->parent->color;\r\n                z->parent->parent->color = ch;\r\n                rightRotate(root,z->parent);\r\n                LeftRotate(root,z->parent->parent);\r\n            }\r\n        }\r\n    }\r\n    (*root)->color = ''B''; //keep root always black\r\n}\r\n \r\n// Utility function to insert newly node in RedBlack tree\r\nvoid insert(struct node **root, int data)\r\n{\r\n    // Allocate memory for new node\r\n    struct node *z = (struct node*)malloc(sizeof(struct node));\r\n    z->data = data;\r\n    z->left = z->right = z->parent = NULL;\r\n \r\n     //if root is null make z as root\r\n    if (*root == NULL)\r\n    {\r\n        z->color = ''B'';\r\n        (*root) = z;\r\n    }\r\n    else\r\n    {\r\n        struct node *y = NULL;\r\n        struct node *x = (*root);\r\n \r\n        // Follow standard BST insert steps to first insert the node\r\n        while (x != NULL)\r\n        {\r\n            y = x;\r\n            if (z->data < x->data)\r\n                x = x->left;\r\n            else\r\n                x = x->right;\r\n        }\r\n        z->parent = y;\r\n        if (z->data > y->data)\r\n            y->right = z;\r\n        else\r\n            y->left = z;\r\n        z->color = ''R'';\r\n \r\n        // call insertFixUp to fix reb-black tree''s property if it\r\n        // is voilated due to insertion.\r\n        insertFixUp(root,z);\r\n    }\r\n}\r\n \r\n// A utility function to traverse Red-Black tree in inorder fashion\r\nvoid inorder(struct node *root)\r\n{\r\n    if (root == NULL)\r\n        return;\r\n    inorder(root->left);\r\n    printf("%d ", root->data);\r\n    inorder(root->right);\r\n}\r\n \r\n/* Drier program to test above function*/\r\nint main()\r\n{\r\n    struct node *root = NULL;\r\n    insert(&root,5);\r\n    insert(&root,3);\r\n    insert(&root,7);\r\n    insert(&root,2);\r\n    insert(&root,4);\r\n    insert(&root,6);\r\n    insert(&root,8);\r\n    insert(&root,11);\r\n    printf("inorder Traversal Is : ");\r\n    inorder(root);\r\n \r\n    return 0;\r\n}', 'Red-Black Tree is a self-balancing Binary Search Tree (BST) where every node follows following rules.\r\nRedBlackTree\r\n1) Every node has a color either red or black.\r\n\r\n2) Root of tree is always black.\r\n\r\n3) There are no two adjacent red nodes (A red node cannot have a red parent or red child).\r\n\r\n4) Every path from root to a NULL node has same number of black nodes.\r\n\r\nWhy Red-Black Trees?\r\nMost of the BST operations (e.g., search, max, min, insert, delete.. etc) take O(h) time where h is the height of the BST. The cost of these operations may become O(n) for a skewed Binary tree. If we make sure that height of the tree remains O(Logn) after every insertion and deletion, then we can guarantee an upper bound of O(Logn) for all these operations. The height of a Red Black tree is always O(Logn) where n is the number of nodes in the tree.\r\n\r\nComparison with AVL Tree\r\nThe AVL trees are more balanced compared to Red Black Trees, but they may cause more rotations during insertion and deletion. So if your application involves many frequent insertions and deletions, then Red Black trees should be preferred. And if the insertions and deletions are less frequent and search is more frequent operation, then AVL tree should be preferred over Red Black Tree.\r\n\r\nHow does a Red-Black Tree ensure balance?\r\nA simple example to understand balancing is, a chain of 3 nodes is not possible in red black tree. We can try any combination of colors and see all of them violate Red-Black tree property.\r\n\r\nA chain of 3 nodes is nodes is not possible in Red-Black Trees. \r\nFollowing are NOT Red-Black Trees\r\n        30             30               30       \r\n       / \\            /  \\             /  \\\r\n     20  NIL         20   NIL         20   NIL\r\n    / \\             / \\              /  \\   \r\n  10  NIL          10  NIL          10  NIL  \r\nViolates          Violates        Violates\r\nProperty 4.      Property 4       Property 3 \r\n\r\nFollowing are different possible Red-Black Trees with above 3 keys\r\n         20                           20\r\n       /   \\                        /   \\\r\n     10     30                    10     30\r\n    /  \\   /  \\                 /  \\    /  \\\r\n NIL  NIL NIL NIL             NIL  NIL NIL NIL\r\n\r\nFrom the above examples, we get some idea how Red-Black trees ensure balance. Following is an important fact about balancing in Red-Black Trees.\r\n\r\nEvery Red Black Tree with n nodes has height <= 2Log2(n+1)\r\n\r\nThis can be proved using following facts:\r\n1) For a general Binary Tree, let k be the minimum number of nodes on all root to NULL paths, then n >= 2k – 1 (Ex. If k is 3, then n is atleast 7). This expression can also be written as k <= 2Log2(n+1)\r\n\r\n2) From property 4 of Red-Black trees and above claim, we can say in a Red-Black Tree with n nodes, there is a root to leaf path with at-most Log2(n+1) black nodes.\r\n\r\n3) From property 3 of Red-Black trees, we can claim that the number black nodes in a Red-Black tree is at least ? n/2 ? where n is total number of nodes.\r\n\r\nFrom above 2 points, we can conclude the fact that Red Black Tree with n nodes has height <= 2Log2(n+1)\r\n\r\nIn this post, we introduced Red-Black trees and discussed how balance is ensured. The hard part is to maintain balance when keys are added and removed. We will soon be discussing insertion and deletion operations in coming posts on Red-Black tree.\r\n\r\nExercise:\r\n1) Is it possible to have all black nodes in a Red-Black tree?\r\n2) Draw a Red-Black Tree that is not an AVL tree structure wise?\r\n\r\nInsertion and Deletion\r\nRed Black Tree Insertion\r\nRed-Black Tree Deletion\r\n\r\nReferences:\r\nIntroduction to Algorithms 3rd Edition by Clifford Stein, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest\r\nhttp://en.wikipedia.org/wiki/Red%E2%80%93black_tree\r\nVideo Lecture on Red-Black Tree by Tim Roughgarden\r\nMIT Video Lecture on Red-Black Tree\r\nMIT Lecture Notes on Red Black Tree', 'Output:\r\nInorder Traversal Is : 2 3 4 5 6 7 8 11\r\nThis article is contributed by Mohsin Mohammaad. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above', 'Data Structure', 'Data Structure', 10),
(34, 'Wasif Haque', '2015-07-23', 'Templates in C++', 'Template is simple and yet very powerful tool in C++. The simple idea is to pass data type as a parameter so that we don’t need to write same code', 'Class Templates Like function templates, class templates are useful when a class defines something that is independent of data type. Can be useful for classes like LinkedList, BinaryTre, Stack, Queue, Array, etc.\r\nFollowing is a simple example of template Array class.\r\n#include <iostream>\r\nusing namespace std;\r\n \r\ntemplate <typename T>\r\nclass Array {\r\nprivate:\r\n    T *ptr;\r\n    int size;\r\npublic:\r\n    Array(T arr[], int s);\r\n    void print();\r\n};\r\n \r\ntemplate <typename T>\r\nArray<T>::Array(T arr[], int s) {\r\n    ptr = new T[s];\r\n    size = s;\r\n    for(int i = 0; i < size; i++)\r\n        ptr[i] = arr[i];\r\n}\r\n \r\ntemplate <typename T>\r\nvoid Array<T>::print() {\r\n    for (int i = 0; i < size; i++)\r\n        cout<<" "<<*(ptr + i);\r\n    cout<<endl;\r\n}\r\n \r\nint main() {\r\n    int arr[5] = {1, 2, 3, 4, 5};\r\n    Array<int> a(arr, 5);\r\n    a.print();\r\n    return 0;\r\n}\r\n\r\nCan there be more than one arguments to templates?\r\nYes, like normal parameters, we can pass more than one data types as arguments to templates. The following example demonstrates the same.\r\n#include<iostream>\r\nusing namespace std;\r\n \r\ntemplate<class T, class U>\r\nclass A  {\r\n    T x;\r\n    U y;\r\nPublic:\r\n    A() {    cout<<"Constructor Called"<<endl;   }\r\n};\r\n \r\nint main()  {\r\n   A<char, char> a;\r\n   A<int, double> b;\r\n   return 0;\r\n}\r\n\r\nCan we specify default value for template arguments?\r\nYes, like normal parameters, we can specify default arguments to templates. The following example demonstrates the same.\r\n#include<iostream>\r\nusing namespace std;\r\n \r\ntemplate<class T, class U = char>\r\nclass A  {\r\npublic:\r\n    T x;\r\n    U y;\r\n    A() {   cout<<"Constructor Called"<<endl;   }\r\n};\r\n \r\nint main()  {\r\n   A<char> a;  // This will call A<char, char>   \r\n   return 0;\r\n}', 'Templates in C++\r\nTemplate is simple and yet very powerful tool in C++. The simple idea is to pass data type as a parameter so that we don’t need to write same code for different data types. For example a software company may need sort() for different data types. Rather than writing and maintaining the multiple codes, we can write one sort() and pass data type as a parameter.\r\nC++ adds two new keywords to support templates: ‘template’ and ‘typename’. The second keyword can always be replaced by keyword ‘class’.\r\nFunction Templates We write a generic function that can be used for different data types. Examples of function templates are sort(), max(), min(), printArray()\r\n#include <iostream>\r\nusing namespace std;\r\n \r\n// One function works for all data types.  This would work\r\n// even for user defined types if operator ''>'' is overloaded\r\ntemplate <typename T>\r\nT myMax(T x, T y)\r\n{\r\n   return (x > y)? x: y;\r\n}\r\n \r\nint main()\r\n{\r\n  cout << myMax<int>(3, 7) << endl;  // Call myMax for int\r\n  cout << myMax<double>(3.0, 7.0) << endl; // call myMax for double\r\n  cout << myMax<char>(''g'', ''e'') << endl;   // call myMax for char\r\n \r\n  return 0;\r\n}', 'What is the difference between function overloading and templates?\r\nBoth function overloading and templates are examples of polymorphism feature of OOP. Function overloading is used when multiple functions do similar operations, templates are used when multiple functions do identical operations.\r\nHow templates work?\r\nTemplates are expended at compiler time. This is like macros. The difference is, compiler does type checking before template expansion. The idea is simple, source code contains only function/class, but compiled code may contain multiple copies of same function/class.\r\nWhat happens when there is static member in a template class/function?\r\nEach instance of a template contains its own static variable. See Templates and Static variables for more details.\r\nWhat is template specialization?\r\nTemplate specialization allows us to have different code for a particular data type. See Template Specialization for more details.\r\nWhat is template metaprogramming?\r\nSee Template Metaprogramming\r\nYou may also like to take a quiz on templates.\r\nJava also support these features. Java calls it generics .\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'CPP', 'CPP', 15);
INSERT INTO `algorithms` (`algo_id`, `author`, `date`, `title`, `short_note`, `code`, `description`, `analysis`, `category`, `tags`, `View`) VALUES
(35, 'Wasif Haque', '2015-07-23', 'C++ Internals | Default Constructors | Set 1', 'A constructor without any arguments or with default value for every argument, is said to be default constructor. ', '#include <iostream>\r\nusing namespace std;\r\n \r\nclass Base\r\n{\r\npublic:\r\n    // compiler "declares" constructor\r\n};\r\n \r\nclass A\r\n{\r\npublic:\r\n    // User defined constructor\r\n    A()\r\n    {\r\n        cout << "A Constructor" << endl;\r\n    }\r\n \r\n    // uninitialized\r\n    int size;\r\n};\r\n \r\nclass B : public A\r\n{\r\n    // compiler defines default constructor of B, and\r\n    // inserts stub to call A constructor\r\n \r\n    // compiler won''t initialize any data of A\r\n};\r\n \r\nclass C : public A\r\n{\r\npublic:\r\n    C()\r\n    {\r\n        // User defined default constructor of C\r\n        // Compiler inserts stub to call A''s construtor\r\n        cout << "B Constructor" << endl;\r\n \r\n        // compiler won''t initialize any data of A\r\n    }\r\n};\r\n \r\nclass D\r\n{\r\npublic:\r\n    D()\r\n    {\r\n        // User defined default constructor of D\r\n        // a - constructor to be called, compiler inserts\r\n        // stub to call A constructor\r\n        cout << "D Constructor" << endl;\r\n \r\n        // compiler won''t initialize any data of ''a''\r\n    }\r\n \r\nprivate:\r\n    A a;\r\n};\r\n \r\nint main()\r\n{\r\n    Base base;\r\n \r\n    B b;\r\n    C c;\r\n    D d;\r\n \r\n    return 0;\r\n}', 'A constructor without any arguments or with default value for every argument, is said to be default constructor. What is the significance of default constructor? Will the code be generated for every default constructor? Will there be any code inserted by compiler to the user implemented default constructor behind the scenes?\r\n\r\nThe compiler will implicitly declare default constructor if not provided by programmer, will define it when in need. Compiler defined default constructor is required to do certain initialization of class internals. It will not touch the data members or plain old data types (aggregates like array, structures, etc…). However, the compiler generates code for default constructor based on situation.\r\n\r\nConsider a class derived from another class with default constructor, or a class containing another class object with default constructor. The compiler needs to insert code to call the default constructors of base class/embedded object.', 'There are different scenarios in which compiler needs to insert code to ensure some necessary initialization as per language requirement. We will have them in upcoming posts. Our objective is to be aware of C++ internals, not to use them incorrectly.\r\n\r\n— by Venki. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'CPP', 'CPP', 10),
(36, 'Wasif Haque', '2015-07-23', 'Advanced C++ | Virtual Constructor', 'Can we make a class constructor virtual in C++ to create polymorphic objects? No. C++ being static typed (the purpose of RTTI is different) ', '#include <iostream>\r\nusing namespace std;\r\n \r\n//// LIBRARY START\r\nclass Base\r\n{\r\npublic:\r\n \r\n    Base() { }\r\n \r\n    virtual // Ensures to invoke actual object destructor\r\n    ~Base() { }\r\n \r\n    // An interface\r\n    virtual void DisplayAction() = 0;\r\n};\r\n \r\nclass Derived1 : public Base\r\n{\r\npublic:\r\n    Derived1()\r\n    {\r\n        cout << "Derived1 created" << endl;\r\n    }\r\n \r\n    ~Derived1()\r\n    {\r\n        cout << "Derived1 destroyed" << endl;\r\n    }\r\n \r\n    void DisplayAction()\r\n    {\r\n        cout << "Action from Derived1" << endl;\r\n    }\r\n};\r\n \r\nclass Derived2 : public Base\r\n{\r\npublic:\r\n    Derived2()\r\n    {\r\n        cout << "Derived2 created" << endl;\r\n    }\r\n \r\n    ~Derived2()\r\n    {\r\n        cout << "Derived2 destroyed" << endl;\r\n    }\r\n \r\n    void DisplayAction()\r\n    {\r\n        cout << "Action from Derived2" << endl;\r\n    }\r\n};\r\n \r\n//// LIBRARY END\r\n \r\nclass User\r\n{\r\npublic:\r\n \r\n    // Creates Drived1\r\n    User() : pBase(0)\r\n    {\r\n        // What if Derived2 is required? - Add an if-else ladder (see next sample)\r\n        pBase = new Derived1();\r\n    }\r\n \r\n    ~User()\r\n    {\r\n        if( pBase )\r\n        {\r\n            delete pBase;\r\n            pBase = 0;\r\n        }\r\n    }\r\n \r\n    // Delegates to actual object\r\n    void Action()\r\n    {\r\n        pBase->DisplayAction();\r\n    }\r\n \r\nprivate:\r\n    Base *pBase;\r\n};\r\n \r\nint main()\r\n{\r\n    User *user = new User();\r\n \r\n    // Need Derived1 functionality only\r\n    user->Action();\r\n \r\n    delete user;\r\n}\r\n\r\nIn the above sample, assume that the hierarchy Base, Derived1 and Derived2 are part of library code. The class User is utility class trying to make use of the hierarchy. The main function is consuming Base hierarchy functionality via User class.\r\n\r\nThe User class constructor is creating Derived1 object, always. If the User‘s consumer (the main in our case) needs Derived2 functionality, User needs to create “new Derived2()” and it forces recompilation. Recompiling is bad way of design, so we can opt for the following approach.\r\n\r\nBefore going into details, let us answer, who will dictate to create either of Derived1 or Derived2 object? Clearly, it is the consumer of User class. The User class can make use of if-else ladder to create either Derived1 or Derived2, as shown in the following sample,\r\n\r\n#include <iostream>\r\nusing namespace std;\r\n \r\n//// LIBRARY START\r\nclass Base\r\n{\r\npublic:\r\n    Base() { }\r\n \r\n    virtual // Ensures to invoke actual object destructor\r\n    ~Base() { }\r\n \r\n    // An interface\r\n    virtual void DisplayAction() = 0;\r\n};\r\n \r\nclass Derived1 : public Base\r\n{\r\npublic:\r\n    Derived1()\r\n    {\r\n        cout << "Derived1 created" << endl;\r\n    }\r\n \r\n    ~Derived1()\r\n    {\r\n        cout << "Derived1 destroyed" << endl;\r\n    }\r\n \r\n    void DisplayAction()\r\n    {\r\n        cout << "Action from Derived1" << endl;\r\n    }\r\n};\r\n \r\nclass Derived2 : public Base\r\n{\r\npublic:\r\n    Derived2()\r\n    {\r\n        cout << "Derived2 created" << endl;\r\n    }\r\n \r\n    ~Derived2()\r\n    {\r\n        cout << "Derived2 destroyed" << endl;\r\n    }\r\n \r\n    void DisplayAction()\r\n    {\r\n        cout << "Action from Derived2" << endl;\r\n    }\r\n};\r\n \r\n//// LIBRARY END\r\n \r\nclass User\r\n{\r\npublic:\r\n \r\n    // Creates Derived1 or Derived2 based on input\r\n    User() : pBase(0)\r\n    {\r\n        int input; // ID to distinguish between\r\n                   // Derived1 and Derived2\r\n \r\n        cout << "Enter ID (1 or 2): ";\r\n        cin  >> input;\r\n \r\n        while( (input !=  1) && (input !=  2) )\r\n        {\r\n            cout << "Enter ID (1 or 2 only): ";\r\n            cin  >> input;\r\n        }\r\n \r\n        if( input == 1 )\r\n        {\r\n            pBase = new Derived1;\r\n        }\r\n        else\r\n        {\r\n            pBase = new Derived2;\r\n        }\r\n \r\n        // What if Derived3 being added to the class hierarchy?\r\n    }\r\n \r\n    ~User()\r\n    {\r\n        if( pBase )\r\n        {\r\n            delete pBase;\r\n            pBase = 0;\r\n        }\r\n    }\r\n \r\n    // Delegates to actual object\r\n    void Action()\r\n    {\r\n        pBase->DisplayAction();\r\n    }\r\n \r\nprivate:\r\n    Base *pBase;\r\n};\r\n \r\nint main()\r\n{\r\n    User *user = new User();\r\n \r\n    // Need either Derived1 or Derived2 functionality\r\n    user->Action();\r\n \r\n    delete user;\r\n}\r\n\r\nThe above code is *not* open for extension, an inflexible design. In simple words, if the library updates the Base class hierarchy with new class Derived3. How can the User class creates Derived3 object? One way is to update the if-else ladder that creates Derived3 object based on new input ID 3 as shown below,\r\n\r\n#include <iostream>\r\nusing namespace std;\r\n \r\nclass User\r\n{\r\npublic:\r\n    User() : pBase(0)\r\n    {\r\n        // Creates Drived1 or Derived2 based on need\r\n \r\n        int input; // ID to distinguish between\r\n                   // Derived1 and Derived2\r\n \r\n        cout << "Enter ID (1 or 2): ";\r\n        cin  >> input;\r\n \r\n        while( (input !=  1) && (input !=  2) )\r\n        {\r\n            cout << "Enter ID (1 or 2 only): ";\r\n            cin  >> input;\r\n        }\r\n \r\n        if( input == 1 )\r\n        {\r\n            pBase = new Derived1;\r\n        }\r\n        else if( input == 2 )\r\n        {\r\n            pBase = new Derived2;\r\n        }\r\n        else\r\n        {\r\n            pBase = new Derived3;\r\n        }\r\n    }\r\n \r\n    ~User()\r\n    {\r\n        if( pBase )\r\n        {\r\n            delete pBase;\r\n            pBase = 0;\r\n        }\r\n    }\r\n \r\n    // Delegates to actual object\r\n    void Action()\r\n    {\r\n        pBase->DisplayAction();\r\n    }\r\n \r\nprivate:\r\n    Base *pBase;\r\n};\r\n\r\nThe above modification forces the users of User class to recompile, bad (inflexible) design! And won’t close User class from further modifications due to Base extension.\r\n\r\nThe problem is with the creation of objects. Addition of new class to the hierarchy forcing dependents of User class to recompile. Can’t we delegate the action of creating objects to class hierarchy itself or to a function that behaves virtually? By delegating the object creation to class hierarchy (or to a static function) we can avoid the tight coupling between User and Base hierarchy. Enough theory, see the following code,\r\n\r\n#include <iostream>\r\nusing namespace std;\r\n \r\n//// LIBRARY START\r\nclass Base\r\n{\r\npublic:\r\n \r\n    // The "Virtual Constructor"\r\n    static Base *Create(int id);\r\n \r\n    Base() { }\r\n \r\n    virtual // Ensures to invoke actual object destructor\r\n    ~Base() { }\r\n \r\n    // An interface\r\n    virtual void DisplayAction() = 0;\r\n};\r\n \r\nclass Derived1 : public Base\r\n{\r\npublic:\r\n    Derived1()\r\n    {\r\n        cout << "Derived1 created" << endl;\r\n    }\r\n \r\n    ~Derived1()\r\n    {\r\n        cout << "Derived1 destroyed" << endl;\r\n    }\r\n \r\n    void DisplayAction()\r\n    {\r\n        cout << "Action from Derived1" << endl;\r\n    }\r\n};\r\n \r\nclass Derived2 : public Base\r\n{\r\npublic:\r\n    Derived2()\r\n    {\r\n        cout << "Derived2 created" << endl;\r\n    }\r\n \r\n    ~Derived2()\r\n    {\r\n        cout << "Derived2 destroyed" << endl;\r\n    }\r\n \r\n    void DisplayAction()\r\n    {\r\n        cout << "Action from Derived2" << endl;\r\n    }\r\n};\r\n \r\nclass Derived3 : public Base\r\n{\r\npublic:\r\n    Derived3()\r\n    {\r\n        cout << "Derived3 created" << endl;\r\n    }\r\n \r\n    ~Derived3()\r\n    {\r\n        cout << "Derived3 destroyed" << endl;\r\n    }\r\n \r\n    void DisplayAction()\r\n    {\r\n        cout << "Action from Derived3" << endl;\r\n    }\r\n};\r\n \r\n// We can also declare "Create" outside Base\r\n// But it is more relevant to limit it''s scope to Base\r\nBase *Base::Create(int id)\r\n{\r\n    // Just expand the if-else ladder, if new Derived class is created\r\n    // User code need not be recompiled to create newly added class objects\r\n \r\n    if( id == 1 )\r\n    {\r\n        return new Derived1;\r\n    }\r\n    else if( id == 2 )\r\n    {\r\n        return new Derived2;\r\n    }\r\n    else\r\n    {\r\n        return new Derived3;\r\n    }\r\n}\r\n//// LIBRARY END\r\n \r\n//// UTILITY START\r\nclass User\r\n{\r\npublic:\r\n    User() : pBase(0)\r\n    {\r\n        // Receives an object of Base heirarchy at runtime\r\n \r\n        int input;\r\n \r\n        cout << "Enter ID (1, 2 or 3): ";\r\n        cin >> input;\r\n \r\n        while( (input !=  1) && (input !=  2) && (input !=  3) )\r\n        {\r\n            cout << "Enter ID (1, 2 or 3 only): ";\r\n            cin >> input;\r\n        }\r\n \r\n        // Get object from the "Virtual Constructor"\r\n        pBase = Base::Create(input);\r\n    }\r\n \r\n    ~User()\r\n    {\r\n        if( pBase )\r\n        {\r\n            delete pBase;\r\n            pBase = 0;\r\n        }\r\n    }\r\n \r\n    // Delegates to actual object\r\n    void Action()\r\n    {\r\n        pBase->DisplayAction();\r\n    }\r\n \r\nprivate:\r\n    Base *pBase;\r\n};\r\n \r\n//// UTILITY END\r\n \r\n//// Consumer of User (UTILITY) class\r\nint main()\r\n{\r\n    User *user = new User();\r\n \r\n    // Action required on any of Derived objects\r\n    user->Action();\r\n \r\n    delete user;\r\n}', 'Can we make a class constructor virtual in C++ to create polymorphic objects? No. C++ being static typed (the purpose of RTTI is different) language, it is meaningless to the C++ compiler to create an object polymorphically. The compiler must be aware of the class type to create the object. In other words, what type of object to be created is a compile time decision from C++ compiler perspective. If we make constructor virtual, compiler flags an error. In fact except inline, no other keyword is allowed in the declaration of constructor.\r\n\r\nIn practical scenarios we would need to create a derived class object in a class hierarchy based on some input. Putting in other words, object creation and object type are tightly coupled which forces modifications to extended. The objective of virtual constructor is to decouple object creation from it’s type.\r\n\r\nHow can we create required type of object at runtime? For example, see the following sample program.', 'The User class is independent of object creation. It delegates that responsibility to Base, and provides an input in the form of ID. If the library adds new class Derived4, the library modifier will extend the if-else ladder inside Create to return proper object. Consumers of User need not recompile their code due to extension of Base.\r\n\r\nNote that the function Create used to return different types of Base class objects at runtime. It acts like virtual constructor, also referred as Factory Method in pattern terminology.\r\n\r\nPattern world demonstrate different ways to implement the above concept. Also there are some potential design issues with the above code. Our objective is to provide some insights into virtual construction, creating objects dynamically based on some input. We have excellent books devoted to the subject, interested reader can refer them for more information.\r\n\r\n— Venki. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'CPP', 'CPP', 10),
(37, 'Wasif Haque', '2015-07-23', 'Comparison of Exception Handling in C++ and Java', 'Both languages use try, catch and throw keywords for exception handling, and meaning of try, catch and free blocks is also same in both languages. ', '#include <iostream>\r\nusing namespace std;\r\nint main() \r\n{\r\n   int x = -1; \r\n \r\n   // some other stuff   \r\n   try {\r\n      // some other stuff \r\n      if( x < 0 )\r\n      {\r\n         throw x;\r\n      }   \r\n   }\r\n   catch (int x ) {\r\n      cout << "Exception occurred: thrown value is " << x << endl;\r\n   }\r\n   getchar();\r\n   return 0;\r\n}\r\n\r\n2) In C++, there is a special catch called “catch all” that can catch all kind of exceptions.\r\n\r\n#include <iostream>\r\nusing namespace std;\r\nint main() \r\n{\r\n   int x = -1; \r\n   char *ptr;\r\n    \r\n   ptr = new char[256];\r\n    \r\n   // some other stuff   \r\n   try {\r\n      // some other stuff \r\n      if( x < 0 )\r\n      {\r\n         throw x;\r\n      }      \r\n      if(ptr == NULL)\r\n      {\r\n         throw " ptr is NULL ";\r\n      }   \r\n   }\r\n   catch (...) // catch all\r\n   {\r\n      cout << "Exception occurred: exiting "<< endl;\r\n      exit(0);\r\n   }\r\n    \r\n   getchar();\r\n   return 0;\r\n}\r\n\r\n3) In Java, there is a block called finally that is always executed after the try-catch block. This block can be used to do cleanup work. There is no such block in C++.\r\n\r\n// creating an exception type\r\nclass Test extends Exception { }\r\n \r\nclass Main {\r\n   public static void main(String args[]) {\r\n \r\n      try {\r\n         throw new Test();\r\n      }\r\n      catch(Test t) {\r\n         System.out.println("Got the Test Exception");\r\n      }\r\n      finally {\r\n         System.out.println("Inside finally block ");\r\n      }\r\n  }\r\n}', 'Both languages use try, catch and throw keywords for exception handling, and meaning of try, catch and free blocks is also same in both languages. Following are the differences between Java and C++ exception handling.\r\n\r\n1) In C++, all types (including primitive and pointer) can be thrown as exception. But in Java only throwable objects (Throwable objects are instances of any subclass of the Throwable class) can be thrown as exception. For example, following type of code works in C++, but similar code doesn’t work in Java.', '4) In C++, all exceptions are unchecked. In Java, there are two types of exceptions – checked and unchecked. See this for more details on checked vs Unchecked exceptions.\r\n\r\n\r\n\r\n5) In Java, a new keyword throws is used to list exceptions that can be thrown by a function. In C++, there is no throws keyword, the same keyword throw is used for this purpose also.\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'CPP', 'CPP', 10),
(38, 'Wasif Haque', '2015-07-23', 'How are parameters passed in Java?', 'In Java, parameters are always passed by value. For example, following program prints i = 10, j = 20.', '//  Test.java\r\nclass Test {\r\n   // swap() doesn''t swap i and j\r\n   public static void swap(Integer i, Integer j) {\r\n      Integer temp = new Integer(i);\r\n      i = j;\r\n      j = temp;\r\n   }\r\n   public static void main(String[] args) {\r\n      Integer i = new Integer(10);\r\n      Integer j = new Integer(20);\r\n      swap(i, j);\r\n      System.out.println("i = " + i + ", j = " + j);\r\n   }\r\n}', '', '', 'Java', 'Java', 10),
(39, 'Wasif Haque', '2015-07-23', 'Catching base and derived classes as exceptions', 'If both base and derived classes are caught as exceptions then catch block of derived class must appear before the base class.', '#include<iostream>\r\nusing namespace std;\r\n \r\nclass Base {};\r\nclass Derived: public Base {};\r\nint main()\r\n{\r\n   Derived d;\r\n   // some other stuff\r\n   try {\r\n       // Some monitored code\r\n       throw d;\r\n   }\r\n   catch(Base b) { \r\n        cout<<"Caught Base Exception";\r\n   }\r\n   catch(Derived d) {  //This catch block is NEVER executed\r\n        cout<<"Caught Derived Exception";\r\n   }\r\n   getchar();\r\n   return 0;\r\n}\r\n\r\nIn the above C++ code, if we change the order of catch statements then both catch statements become reachable. Following is the modifed program and it prints “Caught Derived Exception”\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n \r\nclass Base {};\r\nclass Derived: public Base {};\r\nint main()\r\n{\r\n   Derived d;\r\n   // some other stuff\r\n   try {\r\n       // Some monitored code\r\n       throw d;\r\n   }\r\n   catch(Derived d) { \r\n        cout<<"Caught Derived Exception";\r\n   }\r\n   catch(Base b) { \r\n        cout<<"Caught Base Exception";\r\n   }\r\n   getchar();\r\n   return 0;\r\n}\r\n\r\nIn Java, catching a base class exception before derived is not allowed by the compiler itself. In C++, compiler might give warning about it, but compiles the code.\r\nFor example, following Java code fails in compilation with error message “exception Derived has already been caught”\r\n\r\n//filename Main.java\r\nclass Base extends Exception {}\r\nclass Derived extends Base  {}\r\npublic class Main {\r\n  public static void main(String args[]) {\r\n    try {\r\n       throw new Derived();\r\n    }\r\n    catch(Base b) {}\r\n    catch(Derived d) {}\r\n  }\r\n}', 'Exception Handling – catching base and derived classes as exceptions:\r\n\r\nIf both base and derived classes are caught as exceptions then catch block of derived class must appear before the base class.\r\n\r\nIf we put base class first then the derived class catch block will never be reached. For example, following C++ code prints “Caught Base Exception”', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Java', 'Java', 10),
(40, 'Wasif Haque', '2015-07-23', 'Default constructor in Java', 'Like C++, Java automatically creates default constructor if there is no default or parameterized constructor written by user, and (like C++)', 'Program 2\r\n\r\n#include<iostream>\r\n \r\nusing namespace std;\r\n \r\nclass myInteger\r\n{\r\n   private:\r\n     int value;\r\n   public: \r\n     myInteger(int v)  // parametrized constructor\r\n     {  value = v;  }\r\n    \r\n     //...other things in class  \r\n};\r\n \r\nint main()\r\n{\r\n  myInteger I1;\r\n  getchar();\r\n  return 0;\r\n}', 'Like C++, Java automatically creates default constructor if there is no default or parameterized constructor written by user, and (like C++) the default constructor automatically calls parent default constructor. But unlike C++, default constructor in Java initializes member data variable to default values (numeric values are initialized as 0, booleans are initialized as false and references are initialized as null).\r\n\r\nFor example, output of the below program is\r\n\r\n0\r\nnull\r\nfalse\r\n0\r\n0.0\r\n\r\n// Main.java\r\nclass Test {\r\n   int i;\r\n   Test t;\r\n   boolean b;\r\n   byte bt;\r\n   float ft;\r\n}\r\n \r\npublic class Main {\r\n    public static void main(String args[]) {\r\n      Test t = new Test(); // default constructor is called.\r\n      System.out.println(t.i);\r\n      System.out.println(t.t);\r\n      System.out.println(t.b);\r\n      System.out.println(t.bt);\r\n      System.out.println(t.ft);\r\n    }\r\n}', '', 'Java', 'Java', 10),
(41, 'Wasif Haque', '2015-07-23', 'Comparison of Inheritance in C++ and Java', 'The purpose of inheritance is same in C++ and Java. Inheritance is used in both languages for reusing code and/or creating is-a relationship', '2) In Java, members of the grandparent class are not directly accessible. See this G-Fact for more details.\r\n\r\n\r\n\r\n3) The meaning of protected member access specifier is somewhat different in Java. In Java, protected members of a class “A” are accessible in other class “B” of same package, even if B doesn’t inherit from A (they both have to be in the same package). For example, in the following program, protected members of A are accessible in B.\r\n\r\n// filename B.java\r\nclass A {\r\n    protected int x = 10, y = 20;\r\n}\r\n  \r\nclass B {\r\n    public static void main(String args[]) {\r\n        A a = new A();\r\n        System.out.println(a.x + " " + a.y);\r\n    }\r\n}\r\n\r\n4) Java uses extends keyword for inheritence. Unlike C++, Java doesn’t provide an inheritance specifier like public, protected or private. Therefore, we cannot change the protection level of members of base class in Java, if some data member is public or protected in base class then it remains public or protected in derived class. Like C++, private members of base class are not accessible in derived class.\r\nUnlike C++, in Java, we don’t have to remember those rules of inheritance which are combination of base class access specifier and inheritance specifier.\r\n\r\n\r\n\r\n5) In Java, methods are virtual by default. In C++, we explicitly use virtual keyword. See this G-Fact for more details.\r\n\r\n\r\n\r\n6) Java uses a separte keyword interface for interfaces, and abstract keyword for abstract classes and abstract functions.\r\n\r\nFollowing is a Java abstract class example.\r\n\r\n// An abstract class example\r\nabstract class myAbstractClass {\r\n    \r\n   // An abstract method\r\n   abstract void myAbstractFun();\r\n   \r\n   // A normal method\r\n   void fun() { \r\n      System.out.println("Inside My fun");\r\n   } \r\n}\r\n \r\npublic class myClass extends myAbstractClass {\r\n   public void myAbstractFun() {\r\n      System.out.println("Inside My fun");\r\n   }\r\n}\r\n\r\nFollowing is a Java interface example\r\n\r\n// An interface example\r\npublic interface myInterface {\r\n   // myAbstractFun() is public and abstract, even if we don''t use these keywords\r\n   void myAbstractFun();  // is same as public abstract void myAbstractFun()\r\n}\r\n \r\n// Note the implements keyword also.\r\npublic class myClass implements myInterface {\r\n   public void myAbstractFun() {\r\n      System.out.println("Inside My fun");\r\n   }\r\n}\r\n\r\n7) Unlike C++, Java doesn’t support multiple inheritance. A class cannot inherit from more than one class. A class can implement multiple interfaces though.\r\n\r\n\r\n\r\n8 ) In C++, default constructor of parent class is automatically called, but if we want to call parametrized constructor of a parent class, we must use Initializer list. Like C++, default constructor of the parent class is automatically called in Java, but if we want to call parametrized constructor then we must use super to call the parent constructor. See following Java example.\r\n\r\npackage main;\r\n  \r\nclass Base {\r\n    private int b;\r\n    Base(int x) {\r\n        b = x;\r\n        System.out.println("Base constructor called");\r\n    }                \r\n}\r\n  \r\nclass Derived extends Base {\r\n    private int d;\r\n    Derived(int x, int y) {\r\n        // Calling parent class parameterized constructor\r\n        // Call to parent constructor must be the first line in a Derived class\r\n        super(x);\r\n        d = y;\r\n        System.out.println("Derived constructor called");\r\n    }                    \r\n}\r\n  \r\nclass Main{\r\n    public static void main(String[] args) {\r\n      Derived obj = new Derived(1, 2);\r\n    }\r\n}', 'Comparison of Inheritance in C++ and Java\r\nThe purpose of inheritance is same in C++ and Java. Inheritance is used in both languages for reusing code and/or creating is-a relationship. There are following differences in the way both languages provide support for inheritance.\r\n\r\n1) In Java, all classes inherit from the Object class directly or indirectly. Therefore, there is always a single inheritance tree of classes in Java, and Object class is root of the tree. In Java, if we create a class that doesn’t inherit from any class then it automatically inherits from Object class . In C++, there is forest of classes; when we create a class that doesn’t inherit from anything, we create a new tree in forest.\r\n\r\nFollowing Java example shows that Test class automatically inherits from Object class.\r\n\r\nclass Test { \r\n    // members of test\r\n}\r\nclass Main {\r\n  public static void main(String[] args) {\r\n    Test t = new Test();    \r\n    System.out.println("t is instanceof Object: " + (t instanceof Object));\r\n  }\r\n}', 'Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.\r\n', 'Java', 'Java', 10),
(42, 'Tarango Khan', '2015-07-23', 'Basic Input Output in C++', 'In c++ sometimes we can''t take input for some specific inputs.This post is to help in that cases.', '//============================================================================\r\n// Name        : Input Output and Type Conversions in C++\r\n// Author      : Tarango Khan\r\n// Team        : BRACU Byteheads\r\n//============================================================================\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint str2int(string s) {\r\n	stringstream ss(s);\r\n	int x;\r\n	ss >> x;\r\n	return x;\r\n}\r\n\r\nstring int2str(int a) {\r\n	stringstream ss;\r\n	ss << a;\r\n	string str = ss.str();\r\n	return str;\r\n}\r\n\r\nstring char2str(char a) {\r\n	stringstream ss;\r\n	ss << a;\r\n	string str = ss.str();\r\n	return str;\r\n}\r\n\r\nstring reverse(string s) {\r\n	for (int i = 0, j = s.length() - 1; i < j; i++, j--) {\r\n		swap(s[i], s[j]);\r\n	}\r\n	return s;\r\n}\r\n\r\nint binary2int(int num) {\r\n	int bin = num, dec = 0, rem, base = 1;\r\n	cin >> num;\r\n	bin = num;\r\n	while (num > 0) {\r\n		rem = num % 10;\r\n		dec = dec + rem * base;\r\n		base = base * 2;\r\n		num = num / 10;\r\n	}\r\n	cout << "The decimal equivalent of " << bin << " : " << dec << endl;\r\n	return dec;\r\n}\r\n\r\nstring int2binary(unsigned int val) {\r\n	unsigned int mask = 1 << (sizeof(int) * 8 - 1);\r\n	string s = "";\r\n	for (int i = 0; i < (int) (sizeof(int) * 8); i++) {\r\n		if ((val & mask) == 0) {\r\n			s.append("0");\r\n		} else {\r\n			s.append("1");\r\n		}\r\n		mask >>= 1;\r\n	}\r\n	cout << "The binary equivalent of " << val << " : " << s << endl;\r\n	return s;\r\n}\r\n\r\nbool is_the_double_is_integer(double value) {\r\n	int num = ceil(value);\r\n	double newValue = (double) num;\r\n	if (abs(value - newValue) <= 0.00000000000001) {\r\n		return true;\r\n	} else {\r\n		return false;\r\n	}\r\n}\r\n\r\nstring char_array_2_string(char * a) {\r\n	int Len = strlen(a);\r\n	string s = "";\r\n	for (int i = 0; i < Len; i++) {\r\n		s = s.append(char2str(a[i]));\r\n	}\r\n	return s;\r\n}\r\n\r\nchar * string_2_char_array(string s) {\r\n	int Len = s.length();\r\n	char a[Len + 1];\r\n	for (int i = 0; i < Len; i++) {\r\n		a[i] = s[i];\r\n	}\r\n	a[Len] = ''\\0'';\r\n	return a;\r\n}\r\n\r\nstring remove_leading_space(string s) {\r\n	string t = "";\r\n	int Len = s.length();\r\n	int i = 0;\r\n	while (i < Len && s[i] == '' '')\r\n		i++;\r\n	for (int c = i; c < Len; c++) {\r\n		t = t.append(char2str(s[c]));\r\n	}\r\n	return t;\r\n}\r\n\r\nstring remove_trailing_space(string s) {\r\n	string t = "";\r\n	int Len = s.length();\r\n	int i = Len - 1;\r\n	while (i >= 0 && s[i] == '' '')\r\n		i--;\r\n	for (int c = 0; c <= i; c++) {\r\n		t = t.append(char2str(s[c]));\r\n	}\r\n	return t;\r\n}\r\n\r\nvoid string_input_coma_delimetre() {\r\n	char tokenstring[] = "Hello,25.5,World,15";\r\n	int i;\r\n	double fp;\r\n	char o[10], f[10], s[10], t[10];\r\n\r\n	int result = sscanf(tokenstring, "%[^'',''],%[^'',''],%[^'',''],%s", o, s, t, f);\r\n	fp = atof(s); //Convert from string to float;\r\n	i = atoi(f); //Convert from string to int;\r\n	printf(" %s\\n %lf\\n %s\\n %d\\n", o, fp, t, i);\r\n}\r\n\r\nvoid string_input_other_delimetre() {\r\n	char text[120] = "hello.123.234.223";\r\n	int a[3] = { -1, -1, -1 };\r\n	char str[120];\r\n	sscanf(text, "%[a-z-A-Z].%d.%d.%d", &str, &a[0], &a[1], &a[2]);\r\n\r\n	//%[a-z-A-Z] indicate to store all characters from a to z, A to Z.\r\n	//And you can add in any symbol and numbers such as add in 0-9 and underscore.\r\n	//Example : %[a-z-A-Z-0-9-_]\r\n	printf("%s, %d, %d, %d\\n", str, a[0], a[1], a[2]);\r\n}\r\n\r\nvoid sscanf_known_no_of_inputs_in_a_line() {\r\n	char sentence[] = "Rudolph is 12 years old";\r\n	char s1[20], s2[20], s3[20], s4[20];\r\n	int i;\r\n	sscanf(sentence, "%s %s %d %s %s", &s1, &s2, &i, &s3, &s4);\r\n	printf("%s\\n%s\\n%d\\n%s\\n%s\\n", s1, s2, i, s3, s4);\r\n}\r\n\r\nvoid stringstream_unknown_no_of_integer_inputs_in_a_line() {\r\n	stringstream ss;\r\n	string input = "a b c 4 e 10 15 frd 20 50 hh 100";\r\n	ss << input;\r\n	int found;\r\n	string temp;\r\n\r\n	while (getline(ss, temp, '' '')) {\r\n		if (stringstream(temp) >> found) {\r\n			cout << found << endl;\r\n		}\r\n	}\r\n}\r\n\r\nvoid unknown_no_of_any_inputs_in_a_line() {\r\n	char input[] = "10 12 hello 15 20 hahaha 30 Good 50";\r\n	int Len = strlen(input);\r\n	string s = "";\r\n	for (int i = 0; i < Len; i++) {\r\n		if (input[i] == '' '') {\r\n			if (s.length() != 0) {\r\n				if (s[0] >= ''0'' && s[0] <= ''9'') {\r\n					int int_value = str2int(s);\r\n					cout << "The int value is: " << int_value << endl;\r\n				} else {\r\n					cout << "The string value is: " << s << endl;\r\n				}\r\n			}\r\n			s = "";\r\n		} else {\r\n			s = s.append(char2str(input[i]));\r\n		}\r\n	}\r\n\r\n	//For the last value:\r\n	if (s.length() != 0) {\r\n		if (s[0] >= ''0'' && s[0] <= ''9'') {\r\n			int int_value = str2int(s);\r\n			cout << "The int value is: " << int_value << endl;\r\n		} else {\r\n			cout << "The string value is: " << s << endl;\r\n		}\r\n	}\r\n}\r\n\r\nint main() {\r\n	return 0;\r\n}', '', '', 'Input Output', 'Input Output', 50),
(43, 'Wasif Haque', '2015-07-23', 'Beginners Tips 1', 'Recently I participated in a few Programming Contests: Garmin Programming Competition 2014, ACM programming contest at my University and Google Code Jam 2014.', '', 'Recently I participated in a few Programming Contests: Garmin Programming Competition 2014, ACM programming contest at my University and Google Code Jam 2014. I also remember my first contest in algorithms KPI-Open 2011, in Kiev, Ukraine. It was for teams up to 3 people. There was 16 problems to solve during 2 days. We solved one.\r\n\r\nIn some contests, there is no access to the Internet. It was the case during my first contest (KPI-Open 2011). We were able to use Java, C++ or Pascal. First problem we faced was: “HOW TO READ INPUT FROM CONSOLE IN JAVA?”. None of us remembered. Fortunately, we knew how to do it in C++. Thus we had to use C++ for the first day. We were more proficient in Java though and it slower our development. Before day two, we created check-sheet (we could bring as much printed papers as we wanted) with reading input in Java and some other tricks, which you usually google for. It allowed us to solve one problem. By solving problem I mean, to deliver solution, which pass tests in required amount of time. We solved 7-8 problems (or even more?) during those two days, but only 1 got accepted. It gave us 64 place (among 83 teams).\r\n\r\nA few months after that, I participated in ACM programming contest at Kansas State University with one friend of mine. There was a progress: 1 problem solved in 5 hours (1 day). It is better that 1 problem in 2 days :) Last year, I was 1-person team, and I got 3 problems solved (I was somewhere around 6-10 place). This year: I also solved 3 problems, but it gave me 3rd place.\r\n\r\nLast year, I was also participating in Google Code Jam. In this contest you just need to deliver solution for given input. You download input file from website and you have some amount of time to upload solution (usually up to 10 minutes). Additionally, in most of problems there is small input set and large input set. The large set has more test cases and/or bigger numbers (e.g. int is not enough to solve it).\r\n\r\nThe most important thing during the Programming Contests is time. Time, in which you solve the problem.\r\n\r\nMy general tips (based on competitions I participated in) how to prepare for programming contests:\r\n\r\nMake preparation before. Do not just walk-in (especially if it is your first contest). Check Programming Contest Year Plan – Yes a year Plan to be a better Programmer.\r\nTake Introduction to Algorithms book to the contest.\r\nCreate (and print if no internet access is allowed) template for standard program. 90% of problems has N test cases. You need to parse it, compute solution and print. My approach is to read all input first and serialize it to e.g. Case class. Then I am looping through all cases and printing output. I prepared a template file, which allows me to save time during the contest.\r\nFind out what languages/technologies are allowed during the contest and practice with it before the contest. Programming in Eclipse is different than programming in Visual Studio! Especially debugging.\r\nFind out how you need to provide solution (send source code or just solution?) and how to read/write input/output.\r\nIf possible, find problems from previous editions of particular contest and practice by solving them.\r\nDon’t be afraid to write bad code. You don’t need to comply with the best practices. It doesn’t matter, whether your code is not SOLID. Your code is not readable? Who cares? Don’t waste time for refactoring. If you really feel bad with the code your have written – refactor it after the contest. The only thing, which matters is, whether it solve the problem efficiently. Check solutions of the best competitors at Google Code Jam World Finals 2013. Can I write better code? Sure I can. But nobody cares, because they (not me) were the best in last year contest.\r\nSolving algorithmic problems is only part of programmers’ skills toolset. If somebody is not good at it, it does not mean he is a bad programmer. He may be good at something else (e.g. programming embedded devices for aircrafts or designing the rocket system). However, it is good to practice problems solving and writing code. It is like daily workout. The programmer who wrote 1000 programs will be always better than one who wrote only 10. You will definitely become a better programmer with programming challenges.', '', 'Beginners', 'Beginners', 10),
(44, 'Wasif Haque', '2015-07-23', 'This page contains information about common errors in past programming contests, includes some gener', '', '', 'This page contains information about common errors in past programming contests, includes some general tips for future contests.\r\n\r\nGeneral Tips\r\n\r\nSome of these "tips" might seem unreasonable or impractical at first. But, they help reduce the amount of "unnecessary" errors. After a little time they become second nature and will save headaches during contests. Remember that these tips are for programming contests ONLY. They do not necessarily represent good programming style.\r\n\r\nKnow the details of your IO routines\r\nThis may seem obvious, but it is important. You don''t want to spend what limited time you have during the contest figuring out how to do IO. What you don''t know here will hurt you. Recall that the Java number formatter added a comma to the number by default. We were nice in judging this because it should be a learning exercise. But in a "real" contest the programs would not have been excepted.\r\nAlways use doubles\r\nOK, don''t always use them, but NEVER use floats. Carrying operations to a higher precision inside a program will never make an answer wrong, but not using the doubles can cause problems sometimes. If you always use them you will never have that problem.\r\nEnd you output with a newline\r\nNote: This does not mean put an extra blank line at the end of your output, it just means that EVERY line your program produces should end with a ''\\n''. There are a number of reasons for this, but the easiest to understand is "You ended every other line in your output with a newline, what makes the last line any different?"\r\nDon''t use exceptions -- even in Java\r\nExceptions are just that, exceptions. They are used when there is a problem, NOT in the normal course of execution. If, for example, you are expecting a file to end CHECK FOR IT. Don''t let an end of file exception, or any other side effect exception (like null pointer) get thrown. Along the same lines, DON''T catch any exceptions. Exceptions are BAD. They indicate a problem with YOUR code. The judges will guarantee that all the input is valid, so if you program functions correctly it should not generate any exceptions. This means if you get a "run-time error" result back from the judge you know there is a bug with your code that reads / access the test data, NOT an error in your algorithm. This also means that when you get a "wrong answer" you know that there is an error in your algorithm, NOT some other error that threw an exception that caused the output to be incorrect.\r\nAnother motivation for NOT using exceptions is that they introduce many more paths of execution through your code. And the additional paths are not always obvious. So if you don''t use exceptions you will reduce the complexity of your code, making it easier to code correctly the first time, and easier to debug.\r\n\r\nDon''t write ANYTHING to standard error\r\nAssume that the judging scripts will capture BOTH standard out and standard error. Anything written to standard error will cause your program to be rejected with a "wrong answer".\r\nTest your program before you submit it\r\nRun the version of the program you are about to submit. This helps you catch problems like not taking out debug code, and provides a last sanity check. Remember programs that are bounced add 20 minutes per bounce to your final score.\r\nRead the problem carefully\r\nAgain this may seem obvious, but there is a lot of important information that is IMPLIED in the problem statement. It is also possible to skip over important information because you are racing the clock. Take the extra minute to read and understand the problem. And then reread it before you submit your solution to double check.\r\nTest your solution\r\nUse more than the sample data. The judges have their own hidden tests that they use to test your solutions. These hidden tests will test every legal aspect of the problem, including boundary conditions and large cases. Remember that the judges data will never be invalid. The sample data provided in the problem description will not test these boundary conditions. Test them. If you are working in a team try to have a person who didn''t code up the solution generate the test cases. Usually a fresh mind sees things differently and can find problems quicker.\r\nKnow one language well\r\nThis is another one that seems obvious, but it is worth mentioning. Don''t spend time figuring out all the languages the contest is offering. Make sure you know ONE of the well. The judges will guarantee that all problems are solvable in all languages. Having the ability to "select the best language for the problem" do not buy you much, unless you know and are comfortable with all the languages.', '', 'Beginners', 'Beginners', 10),
(45, 'Wasif Haque', '2015-07-23', 'Beginners Tips 3', 'I commend you for wanting to learn more, be it as preparation for programming contests or for some other reason.', '', 'I commend you for wanting to learn more, be it as preparation for programming contests or for some other reason. Now, I’d like to start by clarifying something. Let’s speak frankly for a moment… from my experience with some of the people who have approached me in the past looking for help, I can tell that sometimes novices are under the impression that there must exist some type of “shortcut” or “magical” process that can turn you into an expert programmer and problem solver overnight. Therefore, and understandably so, they become interested in just finding this shortcut which will automatically make every problem seem easy.\r\n\r\nMaybe some experienced programmers agree with that point of view, and they could give you different advice, but I am decidedly not one of them. The more I learn and practise, the more convinced I am of the fact that there are simply no shortcuts, no magic wands that can turn you into an expert on–the–fly. Moreover, there is no one who can do the work for you, even if they wanted to. Your progress depends exclusively on one person, and that is yourself.\r\n\r\nThis means I don’t really have any interesting advice to give you on how to get better in a particular topic or improve your problem solving skills in general. I can simply give you a generic “learn the theory and practice with problems”. That being said, I do have a few tips that may help…\r\n\r\nBooks\r\nFor learning the theory, I think the best is to refer to books. A couple of good ones oriented to programming competitions are:\r\n\r\nProgramming Challenges by Skiena, Revilla.\r\nCompetitive Programming by the Halim brothers (of World of Seven and uHunt fame).\r\nAnd a few more academic ones, where the theory is more rigorously mathematical:\r\n\r\nThe Algorithm Design Manual (a.k.a. the red book) by Skiena.\r\nAlgorithm Design (a.k.a. the black book) by Kleinberg, Tardos.\r\nIntroduction to Algorithms (a.k.a. CLR) by Cormen, Leiserson, Rivest.\r\nConcrete Mathematics by Graham, Knuth, Patashnik.\r\nIf you have the possibility to buy any of these books, I think that would be a great investment. Try looking them up in a public library first to get a feel for the style of writing of each author, you may find some easier to understand than others. Personally, I really like the style of Donald Knuth, who is the author of the classic series of books The Art of Computer Programming and co–author of Concrete Mathematics.\r\n\r\nPractice, Practice, Practice\r\nOther than books, my main recommendation is to just go ahead and try to solve problems, even if you find them beyond your current skill level (I should say, especially if you find them beyond your current level). Investing your time on a problem, even if you can’t solve it for a while, is time well spent, because what you are doing is expanding the limits of your mind little by little, and there will come a time when you can go back to the problem and find it easier to solve, and your solutions in general will become more elegant with time.\r\n\r\nAlso, you can always ask for help if you find it necessary. Many other programmers before you have walked the path you’re in, and I’m sure many will give you a hand if possible.\r\n\r\nWeb References\r\nTry also looking for reference material on the web. Find a topic you find interesting and just search about it. In this regard, sometimes I get asked to reference tutorials or articles to learn a certain topic. I can understand the appeal of asking someone else to tell you what to read; however, there’s a couple of reasons why I usually can’t satisfy this type of request.\r\n\r\nFirst, in most cases, whenever I learn a new topic, I do it through many different means (books, articles, videos, conversations with friends, etc.) and it’s a little hard to pinpoint the exact moment when I felt I finally learned what I wanted, or the exact elements that were the most useful in my learning process. Sometimes the topic I get asked about is something I learned a long time ago, and I can’t even remember the exact references I used.\r\n\r\nSecondly, I hold the belief that different people have different ways to learn. This means that even if I had a group of resources that I felt were perfectly suitable for me to learn a subject, I just can’t guarantee that you or anybody else will feel the same way about them. I think it’s a much better idea to spend the time doing your own research, which is more likely lead you to the best resources you could find according to your own tastes and needs.\r\n\r\nKeep in mind that sometimes you will come across a really good resource (an article on the web, for example), but it may look confusing to you at first, simply because you need to learn some more basic things first. Take your time, and try to progress gradually and steadily at your own pace. Try to avoid skipping things, even if they look too basic for you; sometimes learning those “basic” things are the key to successfully comprehending more advanced topics.\r\n\r\nFinal Tips\r\nHere’s a few extra tips for solving algorithm problems:\r\n\r\nIf you can’t recognise the type of problems you come across with, there are many useful resources that can help you. LightOJ, for example, has its archive categorised so it’s easy to find out the relevant topics that can help you solve each problem. The following websites also have useful information about problems from the UVa archives:\r\nIgor’s UVa tools\r\nUVa toolkit\r\nUse the forum systems from the online judges! You can find many useful information from previous discussions, and you can also ask your own questions, which is an excellent way to quickly speed up your progress.\r\nAn excellent tool to help you determine which problems to solve next is Felix Halim’s uHunt for the UVa OJ. If you haven’t used it yet, give it a try!\r\nTry to solve the problems by yourself as much as possible. The point of all of this is to learn, so you can apply your knowledge when the right time comes, be it in a competition, or when solving a real-life problem. Be patient and don’t be afraid to put on all the effort you deem necessary to solve a problem; it will be worth it.\r\nDon’t forget that solving algorithm problems is primarily a really fun activity. Don’t suffer the problems… enjoy them :).', '', 'Beginners', 'Beginners', 10);
INSERT INTO `algorithms` (`algo_id`, `author`, `date`, `title`, `short_note`, `code`, `description`, `analysis`, `category`, `tags`, `View`) VALUES
(46, 'Wasif Haque', '2015-07-23', 'For an ACM beginner, how should I start?', 'Most of the answers here point out places where one can solve problems.', '', 'Most of the answers here point out places where one can solve problems. I''m going to describe an approach to approaching ACM programming contests which is a bit different. My definition of an ACM beginner is someone who has not done an ACM regional contest before and has essentially no competitive programming experience, so I will try to cover more of the details from starting on working ACM problems to competing in a regional contest.\r\n\r\nFirst, get comfortable with one of C++ and Java. You''re allowed to use C, C++, or Java - using C is more likely to hinder you in the long run, so get acquainted with one of the other two languages. You should be comfortable enough with the language that you can do some simple things. In particular, you should be comfortable with the following:\r\n\r\nReading in data from standard input (the console), or from a file. You must learn how to do this, since that''s how interaction with the program is done.\r\nBasic arithmetic operations with integer numbers as well as real numbers.\r\nBasic operations with strings, like extracting a substring or reversing the string entirely.\r\nArrays, iterating over an array, updating elements in an array.\r\nAs you get more experience, you can learn about more advanced data structures. Vector, priority queue, map, and set are some of them. \r\n\r\nOnce you feel you''re comfortable with your programming language of choice, you should get started working on some simple problems. A fair number of resources has been provided. I''m going to highlight Codeforces (can be found at Codeforces). \r\n\r\nThis is the site I recommend to all my friends who want somewhere to practice programming, be it competitive programming or casual programming. There are a couple reasons why this site is really nice:\r\n\r\nFor one, the problems are all high-quality, and the number of times a problem has been solved is a good signal of how easy the problem is. On other sites (the Peking Online Judge found at Welcome To PKU JudgeOnline comes to mind), the number of solves is a very weak signal of how easy a problem is. \r\n\r\nAlso, one really nice thing about this online judge that most other judges lack is the ability to see what test case you fail on. At the very beginning of your ACM programming experience, you''re going to make some bugs you''ve never seen before, and being able to look at the test case you failed on can help a lot if you''re stuck trying to figure out why your program doesn''t work. With that being said, you''ll get a lot more out of debugging a problem without looking at the test case, because that''s precisely what you''ll be doing in a contest setting. If you''re stuck debugging for more than an hour or so, take a look at the test case and see why your program doesn''t work.\r\n\r\nYour next job will probably be to qualify to represent your university at a regional contest. To do this, keep on practicing solving problems. You can use other online judges for additional practice - look at the other answers for other good online judges.\r\n\r\nFrom here, I''ll assume you''re on your way to regionals.\r\n\r\nIf you haven''t already seen it, understand the ACM-ICPC scoring scheme. In particular, realize that having many wrong submissions is undesirable. It is always worth it to code more slowly and test your code thoroughly before submitting it to avoid having multiple wrong submissions. In an actual contest, nothing is as effective a morale killer as not seeing the Accepted verdict for a program you just submitted.\r\n\r\nYou can also try to learn scoreboard psychology and do a bit of research on other teams in your region. If a team has solved a problem, that means that the problem is solvable. Ignore wrong submissions to other problems. If a particularly strong team in your region solves a problem, that may not be a good sign that you can do it, but if lots of teams start solving a problem that you haven''t solved, you should definitely look at that problem.\r\n\r\nOnce you''re more used to solving contest problems, start working with a team. ACM contests are inherently team contests, and even if you''re not necessarily the strongest person on your team, you can definitely still make a contribution (shameless reference to Nick Wu''s answer to What it is like to participate in ACM-ICPC contests, knowing that you are the weakest member of your team and that your teammates are doing all of the work for you? Do you feel embarrassed? How do you manage?). When  you start preparing for regionals, pick your team early and do a few virtual contests with them. You may want to do regionals from previous years from your region. Do regionals from other regions (as long as the difficulty is comparable - to put it simply, most regionals in North America are easy, for harder regionals, go looking in Europe or Asia. The Northeastern European Regional Contest (NEERC) is commonly thought of as the hardest regional contest in the world).\r\n\r\nIn your team, figure out your role among the team members. Do you do better with coming up with solutions, or are you better/faster at coding? Each person should make a contribution that best matches his/her strengths. For example, on my team, I''m the person who is assigned to coding particularly implementation-heavy problems. One of my teammates has stronger math skills, so he focuses on solving more mathematical problems. Having good synergy can be useful, so develop it before and not during an actual contest.\r\n\r\nOn the day of the contest, don''t get stressed out. It''s very easy to psych yourself out. Start out slowly, and remember everything you''ve learned. Enjoy those 5 hours, because those 5 hours are some of the most exhilarating hours you''ll ever experience.\r\n\r\nYou''ve just completed your first regional contest! Perhaps it ended badly, and you had a program with bugs that you just couldn''t fixed. Perhaps it ended well, and you just solved that problem in the final seconds of the contest. In any event, wait eagerly for the results, and keep your fingers crossed that you''ll go to World Finals. Even if you don''t, don''t take it too hard. The world won''t end just because you don''t go to World Finals. Go do something fun!', '', 'Beginners', 'Beginners', 10),
(47, 'Wasif Haque', '2015-07-23', 'Beginners Tips 2', 'I personally prefer TopCoder, and to begin, here''s some good advice I found:', '', 'I personally prefer TopCoder, and to begin, here''s some good advice I found:\r\n\r\n(Reposting Nikhil Garg''s answer to How should I practice so that I will be at a level where I can approach TopCoder''s Div1-500 problems with confidence?)\r\n\r\nImpatience is a vice, young Jedi. Let''s take it slow, shall we? \r\n\r\nFirst thing, learn how to write a hello world program. This is the easiest part.\r\nThen start solving div2 easy level problems (250 points usually). They only test if you can translate the simplest of the ideas in code or not. Unless you can solve any such problem in score >= 240 on any given day, you just can''t translate your ideas into code. Keep practicing.\r\nNow you know how to code a little. Time to learn some algorithms. Read Topcoder tutorials - they''re an excellent resource - solve all problems linked. Read topcoder forums and get used to the ecosystem. Study some basic algorithm techniques like Dynamic Programming and divide-and-conquer. Study Graph Theory, some Combinatorics and some Number Theory too, all this while solving problems on Topcoder and elsewhere. You can find all the knowledge on internet easily. \r\nIf you''ve reached this stage, you know how to write code and you know enough of basic algorithm theory. Topcoder div1-500 problems are often very tricky, before you start solving them, you should be able to solve div2 250, 500, 1000 and div1 250 point problems.\r\nMake sure you code everything. Solving a problem theoretically is nice and cool but don''t stop there, code it and make sure it passes system test.\r\nOnce it does, remove all the code and start from scratch. Re-write all code. Get it right in first go. See how much your time improves.\r\nStart reading codes of all the top guys - which basically means all reds and targets and several yellows too. These guys are smart and there is plenty you can learn from their code.\r\nGo through editorial of each problem that you solve (or can''t solve). They often come with great insights and alternative solutions etc.\r\nDon''t get used to solving easy problems. It''s a common pitfall. Always solve problems tougher than what you can solve - that is how you learn.\r\n\r\nAnd when you''ve been doing all this for a while, you''re ready. Soon you''d find you''re solving more and more div1-500 pointer problems. Practice is the key from now on. \r\n\r\nWhat we (my ICPC team) did in particular was - maintained a spreadsheet of our Topcoder practice record. We decided to do div1-500 pointers of all matches from 300 onwards. So once you start a match, make sure to finish its problem, even if you''ve to see editorial after struggling for hours. Be persistent and don''t give up. \r\n\r\nHow long do you take before you achieve your goal and how much time you must put in, these are highly subjective questions with no definite answer. It all varies on your speed and ability to grasp. I know it sounds cliche but believe me this is the only correct answer. \r\n\r\nGood luck young Jedi, may the force be with you!', '', 'Beginners', 'Beginners', 10),
(48, 'Tarango Khan', '2015-07-23', 'Basic Input/Output C++', 'The example programs of the previous sections provided little interaction with the user, if any at all.', '', 'The example programs of the previous sections provided little interaction with the user, if any at all. They simply printed simple values on screen, but the standard library provides many additional ways to interact with the user via its input/output features. This section will present a short introduction to some of the most useful. \r\n\r\nC++ uses a convenient abstraction called streams to perform input and output operations in sequential media such as the screen, the keyboard or a file. A stream is an entity where a program can either insert or extract characters to/from. There is no need to know details about the media associated to the stream or any of its internal specifications. All we need to know is that streams are a source/destination of characters, and that these characters are provided/accepted sequentially (i.e., one after another).\r\n\r\nThe standard library defines a handful of stream objects that can be used to access what are considered the standard sources and destinations of characters by the environment where the program runs:\r\n\r\nstream	description\r\ncin	standard input stream\r\ncout	standard output stream\r\ncerr	standard error (output) stream\r\nclog	standard logging (output) stream\r\n\r\nWe are going to see in more detail only cout and cin (the standard output and input streams); cerr and clog are also output streams, so they essentially work like cout, with the only difference being that they identify streams for specific purposes: error messages and logging; which, in many cases, in most environment setups, they actually do the exact same thing: they print on screen, although they can also be individually redirected.\r\n\r\nStandard output (cout)\r\nOn most program environments, the standard output by default is the screen, and the C++ stream object defined to access it is cout.\r\n\r\nFor formatted output operations, cout is used together with the insertion operator, which is written as << (i.e., two "less than" signs).\r\n\r\n1\r\n2\r\n3\r\ncout << "Output sentence"; // prints Output sentence on screen\r\ncout << 120;               // prints number 120 on screen\r\ncout << x;                 // prints the value of x on screen  \r\n\r\n\r\nThe << operator inserts the data that follows it into the stream that precedes it. In the examples above, it inserted the literal string Output sentence, the number 120, and the value of variable x into the standard output stream cout. Notice that the sentence in the first statement is enclosed in double quotes (") because it is a string literal, while in the last one, x is not. The double quoting is what makes the difference; when the text is enclosed between them, the text is printed literally; when they are not, the text is interpreted as the identifier of a variable, and its value is printed instead. For example, these two sentences have very different results:\r\n\r\n1\r\n2\r\ncout << "Hello";  // prints Hello\r\ncout << Hello;    // prints the content of variable Hello \r\n\r\n\r\nMultiple insertion operations (<<) may be chained in a single statement:\r\n\r\n \r\ncout << "This " << " is a " << "single C++ statement";\r\n\r\n\r\nThis last statement would print the text This is a single C++ statement. Chaining insertions is especially useful to mix literals and variables in a single statement:\r\n\r\n \r\ncout << "I am " << age << " years old and my zipcode is " << zipcode;\r\n\r\n\r\nAssuming the age variable contains the value 24 and the zipcode variable contains 90064, the output of the previous statement would be: \r\n\r\nI am 24 years old and my zipcode is 90064 \r\nWhat cout does not do automatically is add line breaks at the end, unless instructed to do so. For example, take the following two statements inserting into cout:\r\ncout << "This is a sentence.";\r\ncout << "This is another sentence."; \r\n\r\nThe output would be in a single line, without any line breaks in between. Something like:\r\n\r\nThis is a sentence.This is another sentence. \r\nTo insert a line break, a new-line character shall be inserted at the exact position the line should be broken. In C++, a new-line character can be specified as \\n (i.e., a backslash character followed by a lowercase n). For example:\r\n\r\n1\r\n2\r\ncout << "First sentence.\\n";\r\ncout << "Second sentence.\\nThird sentence.";\r\n\r\n\r\nThis produces the following output: \r\n\r\nFirst sentence.\r\nSecond sentence.\r\nThird sentence.\r\n\r\nAlternatively, the endl manipulator can also be used to break lines. For example: \r\n\r\n1\r\n2\r\ncout << "First sentence." << endl;\r\ncout << "Second sentence." << endl;\r\n\r\n\r\nThis would print:\r\n\r\nFirst sentence.\r\nSecond sentence.\r\n\r\nThe endl manipulator produces a newline character, exactly as the insertion of ''\\n'' does; but it also has an additional behavior: the stream''s buffer (if any) is flushed, which means that the output is requested to be physically written to the device, if it wasn''t already. This affects mainly fully buffered streams, and cout is (generally) not a fully buffered stream. Still, it is generally a good idea to use endl only when flushing the stream would be a feature and ''\\n'' when it would not. Bear in mind that a flushing operation incurs a certain overhead, and on some devices it may produce a delay.\r\n\r\nStandard input (cin)\r\nIn most program environments, the standard input by default is the keyboard, and the C++ stream object defined to access it is cin.\r\n\r\nFor formatted input operations, cin is used together with the extraction operator, which is written as >> (i.e., two "greater than" signs). This operator is then followed by the variable where the extracted data is stored. For example:\r\n\r\n1\r\n2\r\nint age;\r\ncin >> age;\r\n\r\n\r\nThe first statement declares a variable of type int called age, and the second extracts from cin a value to be stored in it. This operation makes the program wait for input from cin; generally, this means that the program will wait for the user to enter some sequence with the keyboard. In this case, note that the characters introduced using the keyboard are only transmitted to the program when the ENTER (or RETURN) key is pressed. Once the statement with the extraction operation on cin is reached, the program will wait for as long as needed until some input is introduced.\r\n\r\nThe extraction operation on cin uses the type of the variable after the >> operator to determine how it interprets the characters read from the input; if it is an integer, the format expected is a series of digits, if a string a sequence of characters, etc.\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n// i/o example\r\n\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint main ()\r\n{\r\n  int i;\r\n  cout << "Please enter an integer value: ";\r\n  cin >> i;\r\n  cout << "The value you entered is " << i;\r\n  cout << " and its double is " << i*2 << ".\\n";\r\n  return 0;\r\n}\r\nPlease enter an integer value: 702\r\nThe value you entered is 702 and its double is 1404.\r\nEdit & Run\r\n\r\n\r\nAs you can see, extracting from cin seems to make the task of getting input from the standard input pretty simple and straightforward. But this method also has a big drawback. What happens in the example above if the user enters something else that cannot be interpreted as an integer? Well, in this case, the extraction operation fails. And this, by default, lets the program continue without setting a value for variable i, producing undetermined results if the value of i is used later.\r\n\r\nThis is very poor program behavior. Most programs are expected to behave in an expected manner no matter what the user types, handling invalid values appropriately. Only very simple programs should rely on values extracted directly from cin without further checking. A little later we will see how stringstreams can be used to have better control over user input. \r\nExtractions on cin can also be chained to request more than one datum in a single statement:\r\n\r\n \r\ncin >> a >> b;\r\n\r\n\r\nThis is equivalent to:\r\n\r\n1\r\n2\r\ncin >> a;\r\ncin >> b;\r\n\r\n\r\nIn both cases, the user is expected to introduce two values, one for variable a, and another for variable b. Any kind of space is used to separate two consecutive input operations; this may either be a space, a tab, or a new-line character.\r\n\r\ncin and strings\r\nThe extraction operator can be used on cin to get strings of characters in the same way as with fundamental data types:\r\n\r\n1\r\n2\r\nstring mystring;\r\ncin >> mystring;\r\n\r\n\r\nHowever, cin extraction always considers spaces (whitespaces, tabs, new-line...) as terminating the value being extracted, and thus extracting a string means to always extract a single word, not a phrase or an entire sentence.\r\n\r\nTo get an entire line from cin, there exists a function, called getline, that takes the stream (cin) as first argument, and the string variable as second. For example:\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n// cin with strings\r\n#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nint main ()\r\n{\r\n  string mystr;\r\n  cout << "What''s your name? ";\r\n  getline (cin, mystr);\r\n  cout << "Hello " << mystr << ".\\n";\r\n  cout << "What is your favorite team? ";\r\n  getline (cin, mystr);\r\n  cout << "I like " << mystr << " too!\\n";\r\n  return 0;\r\n}\r\nWhat''s your name? Homer Simpson\r\nHello Homer Simpson.\r\nWhat is your favorite team? The Isotopes\r\nI like The Isotopes too!\r\nEdit & Run\r\n\r\n\r\nNotice how in both calls to getline, we used the same string identifier (mystr). What the program does in the second call is simply replace the previous content with the new one that is introduced.\r\n\r\nThe standard behavior that most users expect from a console program is that each time the program queries the user for input, the user introduces the field, and then presses ENTER (or RETURN). That is to say, input is generally expected to happen in terms of lines on console programs, and this can be achieved by using getline to obtain input from the user. Therefore, unless you have a strong reason not to, you should always use getline to get input in your console programs instead of extracting from cin.\r\n\r\nstringstream\r\nThe standard header <sstream> defines a type called stringstream that allows a string to be treated as a stream, and thus allowing extraction or insertion operations from/to strings in the same way as they are performed on cin and cout. This feature is most useful to convert strings to numerical values and vice versa. For example, in order to extract an integer from a string we can write:\r\n\r\n1\r\n2\r\n3\r\nstring mystr ("1204");\r\nint myint;\r\nstringstream(mystr) >> myint;\r\n\r\n\r\nThis declares a string with initialized to a value of "1204", and a variable of type int. Then, the third line uses this variable to extract from a stringstream constructed from the string. This piece of code stores the numerical value 1204 in the variable called myint.\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n// stringstreams\r\n#include <iostream>\r\n#include <string>\r\n#include <sstream>\r\nusing namespace std;\r\n\r\nint main ()\r\n{\r\n  string mystr;\r\n  float price=0;\r\n  int quantity=0;\r\n\r\n  cout << "Enter price: ";\r\n  getline (cin,mystr);\r\n  stringstream(mystr) >> price;\r\n  cout << "Enter quantity: ";\r\n  getline (cin,mystr);\r\n  stringstream(mystr) >> quantity;\r\n  cout << "Total price: " << price*quantity << endl;\r\n  return 0;\r\n}\r\nEnter price: 22.25\r\nEnter quantity: 7\r\nTotal price: 155.75\r\nEdit & Run\r\n\r\n\r\nIn this example, we acquire numeric values from the standard input indirectly: Instead of extracting numeric values directly from cin, we get lines from it into a string object (mystr), and then we extract the values from this string into the variables price and quantity. Once these are numerical values, arithmetic operations can be performed on them, such as multiplying them to obtain a total price.\r\n\r\nWith this approach of getting entire lines and extracting their contents, we separate the process of getting user input from its interpretation as data, allowing the input process to be what the user expects, and at the same time gaining more control over the transformation of its content into useful data by the program.', '', 'Input Output', 'Input Output', 10),
(49, 'Tarango Khan', '2015-07-23', 'Java Basics - Input and Output', 'At the end of this tutorial, you should be able to create a basic Java program that requests input from a user, does something with the information and displays the results.', '', 'Introduction\r\nAt the end of this tutorial, you should be able to create a basic Java program that requests input from a user, does something with the information and displays the results.\r\n\r\nIn this tutorial, we will be making a program that requests the user’s name, the year she/he was born and the current year. It will then display the user’s name and her/his age.\r\n\r\nThe basic structure of a Java program is as follows:\r\n\r\nHide   Copy Code\r\nclass ClassName {\r\n}\r\nThe class name must be the same as the file name, for example. \r\nFor our program, we will call it Tut1. We will call the file name Tut1.java so the structure will be:\r\n\r\nHide   Copy Code\r\nclass Tut1{\r\n}\r\nWithin a class, you will find methods. The structure of these is as follows:\r\n\r\nHide   Copy Code\r\nmethodName( ){\r\n}\r\nYou will notice that there are brackets after the method name. You can place variable names within these brackets which will receive the values passed to the method. I will talk more about this at a later stage.\r\n\r\nThe most common method that you will use is the ‘main’ method. The class that is actually executed must have this method in the class. However not every class must have a ‘main’ method. The structure of the main method is as follows:\r\n\r\nHide   Copy Code\r\npublic static void main(String args[])\r\n{\r\n}\r\nNote the capital ‘S’ for String. This is important or you will receive an error.\r\n\r\nI believe that there are many different ways of outputting text. I will use one method which uses the standard java package.\r\n\r\nHide   Copy Code\r\nSystem.out.println("Welcome To My First Java Program ");\r\nAgain in this example, note the capital ‘S’ for System. \r\nThis code basically prints a line of text which is contained within the quotes. The line is terminated, like most lines in java, with a semi colon.\r\n\r\nIf we put all this code together, it will look like this:\r\n\r\nHide   Copy Code\r\nclass Tut1 {\r\n     public static void main(String args[])\r\n     	{\r\n          System.out.println("Welcome To My First Java Program");\r\n     }	\r\n}\r\nThis program will output the following on the screen:\r\n\r\nHide   Copy Code\r\nWelcome To My First Java Program \r\nThis is the most basic program you can make that provides any functionality.\r\n\r\nNext we will extend this program to request data from the user via the keyboard. \r\nTo read input from the keyboard, we will use the standard java classes. We will need to use the IOException class which is in the java.io package.\r\n\r\nTo use this class, we must import the java.io package into this class. This is done by the following:\r\n\r\nHide   Copy Code\r\nimport java.io.* ;\r\nThere are many other packages that you can import in a similar manner.\r\n\r\nThe first step is to create the InputStreamReader. The format is as follows:\r\n\r\nHide   Copy Code\r\nInputStreamReader varName = new InputStreamReader(System.in) ;\r\nThis will create the reader and assign it to the variable varName. You can change varName to whatever you want provided you follow the naming rules for a variable. \r\nThis code does the actual reading from the keyboard and converts it to Unicode characters. This is not very useful to us as we want the information in a string. This is where the BufferedReader comes in:\r\n\r\nHide   Copy Code\r\nBufferedReader varName = new BufferedReader(varName) ;\r\nAgain the rules with the variable names apply here. Also note that you cannot have the InputStreamReader and BufferedReader with the same name. I have only done this for demonstration purposes. Also the varName within the brackets in the BufferedReader must be the variable name or your InputStreamReader. \r\nHere is an example of the actual code that we will use for our project:\r\n\r\nHide   Copy Code\r\nInputStreamReader istream = new InputStreamReader(System.in) ;\r\n\r\nBufferedReader bufRead = new BufferedReader(istream) ;\r\nNote the case of the characters and the semicolons.\r\n\r\nFor this example, we want to read a line in. You can do this by the following:\r\n\r\nHide   Copy Code\r\nString firstName = bufRead.readLine();\r\n*Note the capital L.\r\n\r\nTo read from the keyboard, you must also create a try catch block:\r\n\r\nHide   Copy Code\r\ntry {\r\n}\r\ncatch (IOException err) {\r\n}\r\nTo use a try catch block, you place the code for reading the values in, in the try section and in the catch block, you place any error messages, or what to do if there is an error. \r\nHere is the code for our project:\r\n\r\nHide   Copy Code\r\ntry {\r\n     String firstName = bufRead.readLine();\r\n}\r\ncatch (IOException err) {\r\n     System.out.println("Error reading line");\r\n}\r\nThis will try to read the input. It will then catch any IOException errors and print out a user friendly error if one occurs. In this case the error is "Error reading line". \r\nWithin the try block, we will also ask the user to enter in their first name or the user won''t know what she/he is supposed to enter:\r\n\r\nHide   Copy Code\r\ntry {\r\n     System.out.println("Please Enter In Your First Name: ");\r\n     string firstName = bufRead.readLine();\r\n}\r\ncatch (IOException err) {\r\n     System.out.println("Error reading line");\r\n}\r\nLet''s now put what we have so far of our code together.\r\n\r\nHide   Copy Code\r\nimport java.io.* ;\r\nclass Tut1 {\r\n     public static void main(String args[])\r\n     {\r\n               InputStreamReader istream = new InputStreamReader(System.in) ;\r\n               BufferedReader bufRead = new BufferedReader(istream) ;\r\n               \r\n               System.out.println("Welcome To My First Java Program");\r\n          try {\r\n               System.out.println("Please Enter In Your First Name: ");\r\n               String firstName = bufRead.readLine();\r\n          }\r\n          catch (IOException err) {\r\n               System.out.println("Error reading line");\r\n          }\r\n     }	\r\n}\r\nCongratulations! You have now made a fairly useless program. It asks for information and does nothing with it.\r\n\r\nWe will now expand on this base code. \r\nWe also want to ask for the user’s birth year and the current year:\r\n\r\nHide   Copy Code\r\nSystem.out.println("Please Enter In The Year You Were Born: ");\r\nString bornYear = bufRead.readLine();\r\n\r\nSystem.out.println("Please Enter In The Current Year: ");\r\nString thisYear = bufRead.readLine();\r\nFrom this information, we want to calculate the person’s age. But there is a problem - how do you take a string from another string. You can''t, so we must change the string value into a numeric value. We will convert the string values into Integer values using the parseInt function:\r\n\r\nHide   Copy Code\r\nint bYear = Integer.parseInt(bornYear);\r\nint tYear = Integer.parseInt(thisYear);\r\nThis code must go in a try catch block. You can then catch the conversion error:\r\n\r\nHide   Copy Code\r\ncatch(NumberFormatException err) {\r\n     System.out.println("Error Converting Number");\r\n}\r\nThe next step is to calculate the age of the person and output all the data:\r\n\r\nHide   Copy Code\r\nint age = tYear – bYear ;\r\nSystem.out.println(“Hello “ + firstName + ". You are " + age + " years old");\r\nThe last step is to combine all our code:\r\n\r\nHide   Shrink    Copy Code\r\nimport java.io.* ;\r\n\r\nclass Tut1 {\r\n     public static void main(String args[])\r\n     {\r\n          InputStreamReader istream = new InputStreamReader(System.in) ;\r\n          BufferedReader bufRead = new BufferedReader(istream) ;\r\n\r\n          System.out.println("Welcome To My First Java Program");\r\n	\r\n          try {\r\n               System.out.println("Please Enter In Your First Name: ");\r\n               String firstName = bufRead.readLine();\r\n\r\n               System.out.println("Please Enter In The Year You Were Born: ");\r\n               String bornYear = bufRead.readLine();\r\n\r\n               System.out.println("Please Enter In The Current Year: ");\r\n               String thisYear = bufRead.readLine();\r\n\r\n               int bYear = Integer.parseInt(bornYear);\r\n               int tYear = Integer.parseInt(thisYear);\r\n\r\n               int age = tYear – bYear ;\r\n               System.out.println("Hello " + firstName + ". \r\n				You are " + age + " years old");\r\n          }\r\n          catch (IOException err) {\r\n               System.out.println("Error reading line");\r\n          }\r\n          catch(NumberFormatException err) {\r\n               System.out.println("Error Converting Number");\r\n          }			\r\n     }\r\n}\r\nWell, that’s your first basic Java program and the end of my first tutorial. \r\nIf you are interested in more tutorials by me, check out my site www.jcroucher.com.\r\n\r\nHistory\r\n5th September, 2002: Initial post\r\nLicense\r\nThis article has no explicit license attached to it but may contain usage terms in the article text or the download files themselves. If in doubt please contact the author via the discussion board below.\r\n\r\nA list of licenses authors might use can be found here', '', 'Input Output', 'Input Output', 10),
(50, 'Tarango Khan', '2015-07-23', 'Dynamic Programming | Set 17 (Palindrome Partitioning)', 'Given a string, a partitioning of the string is a palindrome partitioning if every substring of the partition is a palindrome.', '// Dynamic Programming Solution for Palindrome Partitioning Problem\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <limits.h>\r\n  \r\n// A utility function to get minimum of two integers\r\nint min (int a, int b) { return (a < b)? a : b; }\r\n  \r\n// Returns the minimum number of cuts needed to partition a string\r\n// such that every part is a palindrome\r\nint minPalPartion(char *str)\r\n{\r\n    // Get the length of the string\r\n    int n = strlen(str);\r\n  \r\n    /* Create two arrays to build the solution in bottom up manner\r\n       C[i][j] = Minimum number of cuts needed for palindrome partitioning\r\n                 of substring str[i..j]\r\n       P[i][j] = true if substring str[i..j] is palindrome, else false\r\n       Note that C[i][j] is 0 if P[i][j] is true */\r\n    int C[n][n];\r\n    bool P[n][n];\r\n  \r\n    int i, j, k, L; // different looping variables\r\n  \r\n    // Every substring of length 1 is a palindrome\r\n    for (i=0; i<n; i++)\r\n    {\r\n        P[i][i] = true;\r\n        C[i][i] = 0;\r\n    }\r\n  \r\n    /* L is substring length. Build the solution in bottom up manner by\r\n       considering all substrings of length starting from 2 to n.\r\n       The loop structure is same as Matrx Chain Multiplication problem (\r\n       See http://www.geeksforgeeks.org/archives/15553 )*/\r\n    for (L=2; L<=n; L++)\r\n    {\r\n        // For substring of length L, set different possible starting indexes\r\n        for (i=0; i<n-L+1; i++)\r\n        {\r\n            j = i+L-1; // Set ending index\r\n  \r\n            // If L is 2, then we just need to compare two characters. Else\r\n            // need to check two corner characters and value of P[i+1][j-1]\r\n            if (L == 2)\r\n                P[i][j] = (str[i] == str[j]);\r\n            else\r\n                P[i][j] = (str[i] == str[j]) && P[i+1][j-1];\r\n  \r\n            // IF str[i..j] is palindrome, then C[i][j] is 0\r\n            if (P[i][j] == true)\r\n                C[i][j] = 0;\r\n            else\r\n            {\r\n                // Make a cut at every possible localtion starting from i to j,\r\n                // and get the minimum cost cut.\r\n                C[i][j] = INT_MAX;\r\n                for (k=i; k<=j-1; k++)\r\n                    C[i][j] = min (C[i][j], C[i][k] + C[k+1][j]+1);\r\n            }\r\n        }\r\n    }\r\n  \r\n    // Return the min cut value for complete string. i.e., str[0..n-1]\r\n    return C[0][n-1];\r\n}\r\n  \r\n// Driver program to test above function\r\nint main()\r\n{\r\n   char str[] = "ababbbabbababa";\r\n   printf("Min cuts needed for Palindrome Partitioning is %d",\r\n           minPalPartion(str));\r\n   return 0;\r\n}\r\n\r\nAn optimization to above approach\r\nIn above approach, we can calculating minimum cut while finding all palindromic substring. If we finding all palindromic substring 1st and then we calculate minimum cut, time complexity will reduce to O(n2).\r\nThanks for Vivek for suggesting this optimization.\r\n\r\n// Dynamic Programming Solution for Palindrome Partitioning Problem\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <limits.h>\r\n  \r\n// A utility function to get minimum of two integers\r\nint min (int a, int b) { return (a < b)? a : b; }\r\n  \r\n// Returns the minimum number of cuts needed to partition a string\r\n// such that every part is a palindrome\r\nint minPalPartion(char *str)\r\n{\r\n    // Get the length of the string\r\n    int n = strlen(str);\r\n  \r\n    /* Create two arrays to build the solution in bottom up manner\r\n       C[i] = Minimum number of cuts needed for palindrome partitioning\r\n                 of substring str[0..i]\r\n       P[i][j] = true if substring str[i..j] is palindrome, else false\r\n       Note that C[i] is 0 if P[0][i] is true */\r\n    int C[n];\r\n    bool P[n][n];\r\n  \r\n    int i, j, k, L; // different looping variables\r\n  \r\n    // Every substring of length 1 is a palindrome\r\n    for (i=0; i<n; i++)\r\n    {\r\n        P[i][i] = true;\r\n    }\r\n  \r\n    /* L is substring length. Build the solution in bottom up manner by\r\n       considering all substrings of length starting from 2 to n. */\r\n    for (L=2; L<=n; L++)\r\n    {\r\n        // For substring of length L, set different possible starting indexes\r\n        for (i=0; i<n-L+1; i++)\r\n        {\r\n            j = i+L-1; // Set ending index\r\n  \r\n            // If L is 2, then we just need to compare two characters. Else\r\n            // need to check two corner characters and value of P[i+1][j-1]\r\n            if (L == 2)\r\n                P[i][j] = (str[i] == str[j]);\r\n            else\r\n                P[i][j] = (str[i] == str[j]) && P[i+1][j-1];\r\n        }\r\n    }\r\n \r\n    for (i=0; i<n; i++)\r\n    {\r\n        if (P[0][i] == true)\r\n            C[i] = 0;\r\n        else\r\n        {\r\n            C[i] = INT_MAX;\r\n            for(j=0;j<i;j++)\r\n            {\r\n                if(P[j+1][i] == true && 1+C[j]<C[i])\r\n                    C[i]=1+C[j];\r\n            }\r\n        }\r\n    }\r\n  \r\n    // Return the min cut value for complete string. i.e., str[0..n-1]\r\n    return C[n-1];\r\n}\r\n  \r\n// Driver program to test above function\r\nint main()\r\n{\r\n   char str[] = "ababbbabbababa";\r\n   printf("Min cuts needed for Palindrome Partitioning is %d",\r\n           minPalPartion(str));\r\n   return 0;\r\n}', 'Given a string, a partitioning of the string is a palindrome partitioning if every substring of the partition is a palindrome. For example, â€œaba|b|bbabb|a|b|abaâ€ is a palindrome partitioning of â€œababbbabbababaâ€. Determine the fewest cuts needed for palindrome partitioning of a given string. For example, minimum 3 cuts are needed for â€œababbbabbababaâ€. The three cuts are â€œa|babbbab|b|ababaâ€. If a string is palindrome, then minimum 0 cuts are needed. If a string of length n containing all different characters, then minimum n-1 cuts are needed.\r\n\r\nSolution\r\nThis problem is a variation of Matrix Chain Multiplication problem. If the string is palindrome, then we simply return 0. Else, like the Matrix Chain Multiplication problem, we try making cuts at all possible places, recursively calculate the cost for each cut and return the minimum value.\r\n\r\nLet the given string be str and minPalPartion() be the function that returns the fewest cuts needed for palindrome partitioning. following is the optimal substructure property.\r\n\r\n// i is the starting index and j is the ending index. i must be passed as 0 and j as n-1\r\nminPalPartion(str, i, j) = 0 if i == j. // When string is of length 1.\r\nminPalPartion(str, i, j) = 0 if str[i..j] is palindrome.\r\n\r\n// If none of the above conditions is true, then minPalPartion(str, i, j) can be \r\n// calculated recursively using the following formula.\r\nminPalPartion(str, i, j) = Min { minPalPartion(str, i, k) + 1 +\r\n                                 minPalPartion(str, k+1, j) } \r\n                           where k varies from i to j-1\r\nFollowing is Dynamic Programming solution. It stores the solutions to subproblems in two arrays P[][] and C[][], and reuses the calculated values.', 'Time Complexity: O(n2)\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Dynamic Programming', '', 10),
(53, 'Tarango Khan', '2015-07-23', 'Longest Palindromic Substring | Set 1', 'Given a string, find the longest substring which is palindrome. For example, if the given string is â€œforgeeksskeegforâ€, the output should be â€œgeeksskeegâ€.', 'Method 2 ( Dynamic Programming ) \r\nThe time complexity can be reduced by storing results of subproblems. The idea is similar to this post. We maintain a boolean table[n][n] that is filled in bottom up manner. The value of table[i][j] is true, if the substring is palindrome, otherwise false. To calculate table[i][j], we first check the value of table[i+1][j-1], if the value is true and str[i] is same as str[j], then we make table[i][j] true. Otherwise, the value of table[i][j] is made false.\r\n\r\n// A dynamic programming solution for longest palindr.\r\n// This code is adopted from following link\r\n// http://www.leetcode.com/2011/11/longest-palindromic-substring-part-i.html\r\n \r\n#include <stdio.h>\r\n#include <string.h>\r\n \r\n// A utility function to print a substring str[low..high]\r\nvoid printSubStr( char* str, int low, int high )\r\n{\r\n    for( int i = low; i <= high; ++i )\r\n        printf("%c", str[i]);\r\n}\r\n \r\n// This function prints the longest palindrome substring\r\n// of str[].\r\n// It also returns the length of the longest palindrome\r\nint longestPalSubstr( char *str )\r\n{\r\n    int n = strlen( str ); // get length of input string\r\n \r\n    // table[i][j] will be false if substring str[i..j]\r\n    // is not palindrome.\r\n    // Else table[i][j] will be true\r\n    bool table[n][n];\r\n    memset(table, 0, sizeof(table));\r\n \r\n    // All substrings of length 1 are palindromes\r\n    int maxLength = 1;\r\n    for (int i = 0; i < n; ++i)\r\n        table[i][i] = true;\r\n \r\n    // check for sub-string of length 2.\r\n    int start = 0;\r\n    for (int i = 0; i < n-1; ++i)\r\n    {\r\n        if (str[i] == str[i+1])\r\n        {\r\n            table[i][i+1] = true;\r\n            start = i;\r\n            maxLength = 2;\r\n        }\r\n    }\r\n \r\n    // Check for lengths greater than 2. k is length\r\n    // of substring\r\n    for (int k = 3; k <= n; ++k)\r\n    {\r\n        // Fix the starting index\r\n        for (int i = 0; i < n-k+1 ; ++i)\r\n        {\r\n            // Get the ending index of substring from\r\n            // starting index i and length k\r\n            int j = i + k - 1;\r\n \r\n            // checking for sub-string from ith index to\r\n            // jth index iff str[i+1] to str[j-1] is a\r\n            // palindrome\r\n            if (table[i+1][j-1] && str[i] == str[j])\r\n            {\r\n                table[i][j] = true;\r\n \r\n                if (k > maxLength)\r\n                {\r\n                    start = i;\r\n                    maxLength = k;\r\n                }\r\n            }\r\n        }\r\n    }\r\n \r\n    printf("Longest palindrome substring is: ");\r\n    printSubStr( str, start, start + maxLength - 1 );\r\n \r\n    return maxLength; // return length of LPS\r\n}\r\n \r\n// Driver program to test above functions\r\nint main()\r\n{\r\n    char str[] = "forgeeksskeegfor";\r\n    printf("\\nLength is: %d\\n", longestPalSubstr( str ) );\r\n    return 0;\r\n}', 'Given a string, find the longest substring which is palindrome. For example, if the given string is â€œforgeeksskeegforâ€, the output should be â€œgeeksskeegâ€.\r\n\r\nMethod 1 ( Brute Force ) \r\nThe simple approach is to check each substring whether the substring is a palindrome or not. We can run three loops, the outer two loops pick all substrings one by one by fixing the corner characters, the inner loop checks whether the picked substring is palindrome or not.\r\n\r\nTime complexity: O ( n^3 )\r\nAuxiliary complexity: O ( 1 )', 'Time complexity: O ( n^2 )\r\nAuxiliary Space: O ( n^2 )\r\n\r\nWe will soon be adding more optimized methods as separate posts.\r\n\r\nPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.', 'Dynamic Programming', 'Dynamic Programming', 10);

-- --------------------------------------------------------

--
-- Table structure for table `blog_registration`
--

CREATE TABLE IF NOT EXISTS `blog_registration` (
  `full_name` varchar(50) NOT NULL,
  `email` varchar(50) NOT NULL,
  `user_name` varchar(50) NOT NULL,
  `user_id` varchar(50) NOT NULL,
  `password` varchar(50) NOT NULL,
  `country` varchar(50) NOT NULL,
  `age` int(2) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `blog_registration`
--

INSERT INTO `blog_registration` (`full_name`, `email`, `user_name`, `user_id`, `password`, `country`, `age`) VALUES
('Tarango Khan', 'tarangokhan77@gmail.com', 'Tarango Khan', '', '123456', 'Bangladesh', 22),
('alif', 'alif@gmail.com', 'alif', '', '123456', 'Bangladesh', 22),
('Wasif Haque', 'wasif@gmail.com', 'Wasif Haque', '', '123456', 'Bangladesh', 22);

-- --------------------------------------------------------

--
-- Table structure for table `comments_article`
--

CREATE TABLE IF NOT EXISTS `comments_article` (
  `user_name` varchar(30) NOT NULL,
  `user_id` int(6) NOT NULL,
  `article_id` int(6) NOT NULL,
  `comment` text NOT NULL,
`comment_id` int(6) NOT NULL,
  `comment_date` varchar(20) NOT NULL
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=15 ;

--
-- Dumping data for table `comments_article`
--

INSERT INTO `comments_article` (`user_name`, `user_id`, `article_id`, `comment`, `comment_id`, `comment_date`) VALUES
('Wasif Haque', 12, 13, 'Nicely written,understood the logic finally!', 1, '2015/07/22 01:11:58p'),
('Wasif Haque', 12, 13, 'Great work bro!', 2, '2015/07/22 01:12:57p'),
('Wasif Haque', 12, 12, 'Owwwww', 3, '2015/07/22 01:13:56p'),
('Wasif Haque', 12, 9, 'How is it working?', 4, '2015/07/22 02:04:18p'),
('Wasif Haque', 12, 47, 'Thanks For Your Advise!', 5, '2015/07/22 10:03:35p'),
('Tarango Khan', 0, 53, 'Thats a very good dp algorithm!', 7, '2015/07/23 09:40:27a'),
('alif', 0, 52, 'Thats great!', 9, '2015/07/23 09:42:10a'),
('alif', 0, 53, 'Well that is pretty impressive!', 10, '2015/07/23 09:13:53p'),
('alif', 0, 53, 'Owwwwwww!!!Awesome!', 11, '2015/07/23 09:14:06p'),
('Tarango Khan', 0, 53, 'Thank you alif.', 12, '2015/07/23 09:23:12p'),
('Tarango Khan', 0, 53, 'I know that btw.', 13, '2015/07/23 09:24:06p'),
('Wasif Haque', 0, 53, 'Tarango and Alif what you guys are talking about!', 14, '2015/07/23 09:26:14p');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `algorithms`
--
ALTER TABLE `algorithms`
 ADD PRIMARY KEY (`algo_id`);

--
-- Indexes for table `blog_registration`
--
ALTER TABLE `blog_registration`
 ADD FULLTEXT KEY `full_name` (`full_name`,`email`,`user_name`,`user_id`,`password`,`country`);

--
-- Indexes for table `comments_article`
--
ALTER TABLE `comments_article`
 ADD PRIMARY KEY (`comment_id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `algorithms`
--
ALTER TABLE `algorithms`
MODIFY `algo_id` int(6) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=54;
--
-- AUTO_INCREMENT for table `comments_article`
--
ALTER TABLE `comments_article`
MODIFY `comment_id` int(6) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=15;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
